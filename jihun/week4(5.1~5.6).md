## 5.1 원시값의 메서드



자바스크립트는 원시값(문자열, 숫자 등)을 마치 객체처럼 다룰 수 있게 해준다. 원시값에도 객체에서처럼 메서드를 호출할 수 있다.  그 전에, **원시값은 객체가 아니란 것을 상기하도록 하자.**



원시값과 객체는 다음과 같은 차이점이 있다.

**원시값**:

- 원시형 값이다.

- 원시형의 종류는 `문자(string)`, `숫자(number)`, `bigint`, `불린(boolean)`, `심볼(symbol)`, `null`, `undefined`형으로 총 일곱 가지 이다.

  

**객체**:

- 프로퍼티에 다양한 종류의 값을 저장할 수 있다.

- `{name : "John", age : 30}`와 같이 대괄호 `{}`를 사용해 만들 수 있다. 자바스크립트에는 여러 종류의 객체가 있는데, 함수도 객체의 일종이다.

  

**객체의 장점** 중 하나는 **함수를 프로퍼티로 저장할 수 있다**는 것이다.

```javascript
let john = {
  name: "John",
  sayHi: function() {
    alert("친구야 반갑다!");
  }
};

john.sayHi(); // 친구야 반갑다!
```

객체 `john`을 만들고, 거기에 메서드 `sayHi`를 정의해보았다.

자바스크립트는 날짜, 오류, HTML 요소(HTML element) 등을 다룰 수 있게 해주는 다양한 내장 객체를 제공한다. 이 객체들은 고유한 프로퍼티와 메서드를 가진다.

하지만, 이런 기능을 사용하면 시스템 자원이 많이 소모된다는 단점이 있다. 객체는 원시값보다 “무겁고”, 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문이다.





#### 원시값을 객체처럼 사용하기

자바스크립트 창안자(creator)는 다음과 같은 모순적인 상황을 해결해야만 했었다.

- 문자열이나 숫자와 같은 원시값을 다루어야 하는 작업이 많은데, 메서드를 사용하면 작업을 수월하게 할 수 있을 것 같다는 생각이 든다.
- 그런데 원시값은 가능한 한 빠르고 가벼워야 한다.



조금 어색해 보이지만, 자바스크립트 창안자는 아래와 같은 방법을 사용해 해결책을 모색하였다.

1. 원시값은 원시값 그대로 남겨둬 단일 값 형태를 유지한다.
2. 문자열, 숫자, 불린, 심볼의 메서드와 프로퍼티에 접근할 수 있도록 언어 차원에서 허용한다.
3. 이를 가능하게 하기 위해, 원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체, "원시 래퍼 객체(object wrapper)"를 만들어 준다. 이 객체는 곧 삭제된다.



"래퍼 객체"는 원시 타입에 따라 종류가 다양하다. 각 래퍼 객체는 원시 자료형의 이름을 그대로 차용해, `String`,`Number`,`Boolean`, `Symbol`라고 부릅니다. 래퍼 객체 마다 제공하는 메서드 역시 다르다.

인수로 받은 문자열의 모든 글자를 대문자로 바꿔주는 메서드 [str.toUpperCase()](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase)를 예로 들어보자.

메서드는 아래와 같이 동작한다.

```javascript
let str = "Hello";

alert( str.toUpperCase() ); // HELLO
```

간단하다. 그리고, 아래는 `str.toUpperCase ()`가 호출될 때 내부에서 실제로 일어나는 일이다.

1. 문자열 `str`은 원시값이므로 원시값의 프로퍼티(toUpperCase)에 접근하는 순간 특별한 객체가 만들어진다. 이 객체는 문자열의 값을 알고 있고, `toUpperCase()`와 같은 유용한 메서드를 가지고 있다.
2. 메서드가 실행되고, 새로운 문자열이 반환된다(`alert` 창에 이 문자열이 출력된다).
3. 특별한 객체는 파괴되고, 원시값 `str`만 남는다.



이런 내부 프로세스를 통해 원시값을 가볍게 유지하면서 메서드를 호출할 수 있는 것이다.

자바스크립트 엔진은 위 프로세스의 최적화에 많은 신경을 쓴다. 원시 래퍼 객체를 만들지 않고도 마치 원시 래퍼 객체를 생성(명세에 언급됨)한 것처럼 동작하게끔 해준다.

숫자형도 고유한 메서드를 지원한다. 메서드 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)를 이용하면 원하는 자리에서 소수점 아래 숫자를 반올림할 수 있다.

```javascript
let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
```



**`String/Number/Boolean`를 생성자론 쓰지 말자.**

Java 등의 몇몇 언어에선 `new Number(1)` 또는 `new Boolean(false)`와 같은 문법을 사용해 원하는 타입의 "래퍼 객체"를 직접 만들 수 있다.

자바스크립트에서도 하위 호환성을 위해 이 기능을 남겨 두었는데, 이런 식으로 **래퍼 객체를 만드는 건 추천하지 않는다**. 몇몇 상황에서 혼동을 불러일으키기 때문이다.



```javascript
alert( typeof 0 ); // "number"

alert( typeof new Number(0) ); // "object"!
```



객체는 논리 평가 시 항상 참을 반환하기 때문에, 아래 예시에서 얼럿창은 무조건 실행된다.

```javascript
let zero = new Number(0);

if (zero) { // 변수 zero는 객체이므로, 조건문이 참이 된다.
  alert( "그런데 zero가 참이라는 것에 동의!?!" );
}
```

그런데, `new`를 붙이지 않고 `String / Number / Boolean`을 사용하는 건 괜찮다. `new` 없이 사용하면 상식에 맞게 인수를 원하는 형의 원시값(문자열, 숫자, 불린 값)으로 바꿔주는데, 아주 유용하다.

```javascript
let num = Number("123"); // 문자열을 숫자로 바꿔줌
```



**`null/undefined`는 메서드가 없다.**

특수 자료형인 `null`과 `undefined`의 원시값(`null/undefined`)은 위와 같은 법칙을 따르지 않는다. 이 자료형과 연관되는 "래퍼 객체"도 없고, 메서드도 제공하지 않는다. 어떤 의미에서는 두 자료형이 "가장 원시적"이라 할 수 있을 것 같다.

두 자료형에 속한 값의 프로퍼티에 접근하려 하면 에러가 발생한다.

```javascript
alert(null.test); // error
```





> 요약
>
> - 'null’과 'undefined’를 제외한 원시값에 다양한 메서드를 호출할 수 있다. 
> - 원시값에 메서드를 호출하려 하면 임시 객체가 만들어진다. 그런데 자바스크립트 엔진은 내부 최적화가 잘 되어있어 메서드를 호출해도 많은 리소스를 쓰지 않는다.









## 5.2 숫자형

모던 자바스크립트는 숫자를 나타내는 두 가지 자료형을 지원한다.

1. 일반적인 숫자는 '배정밀도 부동소수점 숫자(double precision floating point number)'로 알려진 64비트 형식의 [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision)에 저장된다. 
2. 임의의 길이를 가진 정수는 BigInt 숫자로 나타낼 수 있다. 일반적인 숫자는 `253`이상이거나 `-253`이하일 수 없다는 제약 때문에 BigInt라는 새로운 자료형이 만들어졌다. BigInt는 아주 특별한 경우에만 사용되므로, 해당 튜토리얼에서는 별도의 챕터 [BigInt](https://ko.javascript.info/bigint)에서 자세한 내용을 다룬다고 한다. 





#### 숫자를 입력하는 다양한 방법

10억을 입력해야 한다고 상상해 보면 가장 분명한 방법은 아래와 같이 직접 10억(one billion)을 써주는 것이다.

```javascript
let billion = 1000000000;
```

그런데 이렇게 0을 많이 사용해 숫자를 표현하다 보면 잘못 입력하기 쉽기 때문에, 실제로는 이런 방법을 잘 사용하지 않는다. 0을 많이 입력하는 게 귀찮기도 하다. 그래서 대개는 10억(`billion`)을 나타낼 땐 `'1bn'`을 사용하고, 73억을 나타낼 땐 `'7.3bn'`을 사용한다. 큰 숫자를 나타낼 땐 이런 방법이 주로 사용된다.



자바스크립트에서도 숫자 옆에 `'e'`를 붙이고 0의 개수를 그 옆에 붙여주면 숫자를 줄일 수 있다.

```javascript
let billion = 1e9;  // 10억, 1과 9개의 0

alert( 7.3e9 );  // 73억 (7,300,000,000)
```



즉, `'e'`는 e 왼쪽의 수에 e 오른쪽에 있는 수만큼의 10의 거듭제곱을 곱하는 효과가 있다.

```javascript
1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000
```



이제 아주 작은 숫자인 1마이크로초(백만 분의 1초)를 표현해보자.

```javascript
let ms = 0.000001;
```



작은 숫자를 표현할 때도 큰 숫자를 표현할 때처럼 `'e'`를 사용할 수 있다. 0을 명시적으로 쓰고 싶지 않다면 다음과 같이 숫자를 표현할 수 있다.

```javascript
let ms = 1e-6; // 1에서 왼쪽으로 6번 소수점 이동
```



`0.000001`에서 0의 개수를 세면 6이므로 `0.000001`은 당연히 `1e-6`이 된다.

이렇게 `'e'` 우측에 음수가 있으면, 이 음수의 절댓값 만큼 10을 거듭제곱한 수로 나누는 것을 의미한다.

```javascript
// 10을 세 번 거듭제곱한 수로 나눔
1e-3 = 1 / 1000 (=0.001)

// 10을 여섯 번 거듭제곱한 수로 나눔
1.23e-6 = 1.23 / 1000000 (=0.00000123)
```





#### 16진수, 2진수, 8진수

[16진수](https://en.wikipedia.org/wiki/Hexadecimal)는 색을 나타내거나 문자를 인코딩할 때 등 다양한 곳에서 두루 쓰인다. 다양한 곳에서 쓰이는 만큼 당연히 16진수를 짧게 표현하는 방법도 존재하는데, 16진수는 `0x`를 사용해 표현할 수 있다.

```javascript
alert( 0xff ); // 255
alert( 0xFF ); // 255 (대·소문자를 가리지 않으므로 둘 다 같은 값을 나타낸다.)
```



2진수와 8진수는 아주 드물게 쓰이긴 하지만, 접두사 `0b`와 `0o`를 사용해 간단히 나타낼 수 있다.

```javascript
let a = 0b11111111; // 255의 2진수
let b = 0o377; // 255의 8진수

alert( a == b ); // true, 진법은 다르지만, a와 b는 같은 수임
```

자바스크립트에서 지원하는 진법은 3개이다. 이 외의 진법을 사용하려면 함수 `parseInt`를 사용해야 한다(챕터 후반부에서 다룸).





#### toString(base)

`num.toString(base)` 메서드는 `base`진법으로 `num`을 표현한 후, 이를 문자형으로 변환해 반환한다.

```javascript
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

`base`는 `2`에서 `36`까지 쓸 수 있는데, 기본값은 `10` 이다.

`base`별 유스 케이스는 다음과 같다.

- **base=16** – 16진수 색, 문자 인코딩 등을 표현할 때 사용한다. 숫자는 `0`부터 `9`, 10 이상의 수는 `A`부터 `F`를 사용하여 나타낸다.

- **base=2** – 비트 연산 디버깅에 주로 쓰인다. 숫자는 `0` 또는 `1`이 될 수 있다.

- **base=36** – 사용할 수 있는 `base` 중 최댓값으로, `0..9`와 `A..Z`를 사용해 숫자를 표현한다. 알파벳 전체가 숫자를 나타내는 데 사용된다. `36` 베이스는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용하다. 

  ```javascript
  alert( 123456..toString(36) ); // 2n9c
  ```

**점 두 개와 메서드 호출**

`123456..toString(36)`에 있는 점 두 개는 오타가 아니다. 위 예시처럼 숫자를 대상으로 메서드 `toString`을 직접 호출하고 싶다면 숫자 다음에 점 두 개 `..`를 붙여야 한다.

`123456.toString(36)`처럼 점을 한 개만 사용하면, 첫 번째 점 이후는 소수부로 인식되어 에러가 발생할 수 있다. 점을 하나 더 추가하면 자바스크립트는 소수부가 없다고 판단하고 함수를 호출한다.

`(123456).toString(36)`도 가능하다.





#### 어림수 구하기

어림수를 구하는 것(rounding)은 숫자를 다룰 때 가장 많이 사용되는 연산 중 하나이다.

어림수 관련 내장 함수 몇 가지를 살펴보자.

- `Math.floor`

  소수점 첫째 자리에서 내림(버림). `3.1`은 `3`, `-1.1`은 `-2`가 된다.

- `Math.ceil`

  소수점 첫째 자리에서 올림. `3.1`은 `4`, `-1.1`은 `-1`이 된다.

- `Math.round`

  소수점 첫째 자리에서 반올림. `3.1`은 `3`, `3.6`은 `4`, `-1.1`은 `-1`이 된다.

- `Math.trunc` (Internet Explorer에서는 지원하지 않음)

  **소수부를 무시.** `3.1`은 `3`이 되고 `-1.1`은 `-1`이 된다.

  

각 내장 함수의 차이를 표로 나타내면 다음과 같다.

|        | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |
| :----- | :----------- | :---------- | :----------- | :----------- |
| `3.1`  | `3`          | `4`         | `3`          | `3`          |
| `3.6`  | `3`          | `4`         | `4`          | `3`          |
| `-1.1` | `-2`         | `-1`        | `-1`         | `-1`         |
| `-1.6` | `-2`         | `-1`        | `-2`         | `-1`         |

위에서 소개한 내장 함수들만으로도 소수부에 관련된 연산 대부분을 처리할 수 있다. 그런데 소수점 `n-th`번째 수를 기준으로 어림수를 구해야 하는 상황이라면 어떻게 해야 할까? 예를 들어 `1.2345`가 있는데 소수점 두 번째 자릿수까지만 남겨 `1.23`을 만들고 싶은 경우처럼 말이다.



두 가지 방법이 있다.

1. 곱하기와 나누기

   소수점 두 번째 자리 숫자까지만 남기고 싶은 경우, 숫자에 `100` 또는 `100`보다 큰 `10`의 거듭제곱 수를 곱한 후, 원하는 어림수 내장 함수를 호출하고 처음 곱한 수를 다시 나누면 된다.

   ```javascript
   let num = 1.23456;
   
   alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
   ```

   

2. 소수점 `n` 번째 수까지의 어림수를 구한 후 이를 문자형으로 반환해주는 메서드인 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)를 사용한다.

   ```javascript
   let num = 12.34;
   alert( num.toFixed(1) ); // "12.3"
   ```

   **`toFixed`는 `Math.round`와 유사하게 가장 가까운 값으로 올림 혹은 버림해준다.**

   ```javascript
   let num = 12.36;
   alert( num.toFixed(1) ); // "12.4"
   ```

   `toFixed`를 사용할 때 주의할 점은 이 메서드의 반환 값이 문자열이라는 것이다. 소수부의 길이가 인수보다 작으면 끝에 0이 추가된다.

   ```javascript
   let num = 12.34;
   alert( num.toFixed(5) ); // "12.34000", 소수부의 길이를 5로 만들기 위해 0이 추가되었다.
   ```

   참고로, `+num.toFixed(5)`처럼 단항 덧셈 연산자를 앞에 붙이거나 `Number()`를 호출하면 문자형의 숫자를 숫자형으로 변환할 수 있다.





#### 부정확한 계산

숫자는 내부적으로 64비트 형식 [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision)으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요하다. 64비트 중 52비트는 숫자를 저장하는 데 사용되고, 11비트는 소수점 위치를(정수는 0), 1비트는 부호를 저장하는 데 사용된다.

그런데 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리된다.

```javascript
alert( 1e500 ); // Infinity
```



원인을 이해하려면 집중이 필요하긴 하지만, 꽤 자주 발생하는 현상인 정밀도 손실(loss of precision)도 있다.

```javascript
alert( 0.1 + 0.2 == 0.3 ); // false
```

`0.1`과 `0.2`의 합이 `0.3`과 일치하는지 확인 했는데 `false`가 출력되었다.



합의 결과가 `0.3`이 아니라면 대체 무엇일까?

```javascript
alert( 0.1 + 0.2 ); // 0.30000000000000004
```



부정확한 비교 연산이 만들어내는 결과는 여기서 그치지 않는다. 인터넷 쇼핑몰 사이트를 운영하고 있다고 가정해 보면, 사용자가 `$0.10`와 `$0.20` 짜리 물품을 장바구니에 넣었다고 상상해 본다. 주문 총액이 `$0.30000000000000004`인 것을 보고 놀라지 않을 사용자는 없을 것이다. 왜 이런 일이 발생하는 걸까?

숫자는 0과 1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장된다. 그런데 10진법을 사용하면 쉽게 표현할 수 있는 `0.1`, `0.2` 같은 분수는 이진법으로 표현하면 무한 소수가 된다.

`0.1`은 1을 10으로 나눈 수인 `1/10` 이다. 10진법을 사용하면 이러한 숫자를 쉽게 표현할 수 있다. `1/10`과 `1/3`을 비교해보자. `1/3`은 무한 소수 `0.33333(3)`이 된다.

이렇게 `10`의 거듭제곱으로 나눈 값은 10진법에서 잘 동작하지만 `3`으로 나누게 되면 10진법에서 제대로 동작하지 않는다. 같은 이유로 2진법 체계에서 `2`의 거듭제곱으로 나눈 값은 잘 동작하지만 `1/10`같이 `2`의 거듭제곱이 아닌 값으로 나누게 되면 무한 소수가 되어버린다.

10진법에서 1/3을 정확히 나타낼 수 없듯이, 2진법을 사용해 *0.1* 또는 *0.2*를 **정확하게** 저장하는 방법은 없다.

IEEE-754에선 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결한다. 그런데 반올림 규칙을 적용하면 발생하는 '작은 정밀도 손실’을 우리가 볼 수는 없지만 실제로 손실은 발생한다.

아래와 같이 코드를 작성하면 정밀도 손실을 눈으로 확인할 수 있다.

```javascript
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```

그리고 두 숫자를 합하면 '정밀도 손실’도 더해진다.

`0.1 + 0.2`가 정확히 `0.3`이 아닌 이유가 여기에 있다.

**자바스크립트뿐만이 아니다.** 다른 언어에서도 같은 이슈가 있다.

자바스크립트와 동일한 숫자 형식을 사용하기 때문에 PHP, Java, C, Perl, Ruby에서도 똑같은 결과를 얻는다.

문제를 해결하는 방법은 없을까? 물론 있다. 가장 신뢰할만한 방법은 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)메서드를 사용해 어림수를 만드는 것이다.

```javascript
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

이때 `toFixed`는 항상 문자열을 반환한다는 점에 유의해야 한다. 문자열을 반환하기 때문에 소수점 다음에 오는 숫자가 항상 2개가 될 수 있다. 인터넷 쇼핑몰을 구축 중이고 `$0.30`를 보여줘야 할 때 유용하다. 문자형으로 바뀐 숫자를 다시 숫자형으로 강제 변환하려면 단항 덧셈 연산자를 사용하면 된다.

```javascript
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```

숫자에 임시로 100(또는 더 큰 숫자)을 곱하여 정수로 바꾸고, 원하는 연산을 한 후 다시 100으로 나누는 것도 하나의 방법이 될 수 있다. 정수를 대상으로 하는 수학 연산은 소수를 대상으로 하는 연산보다 에러가 적기 때문이다. 그런데 어쨌든 마지막에 나눗셈이 들어가기 때문에 소수가 다시 등장할 수 있다는 단점이 있다.

```javascript
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```

이렇게 10의 거듭제곱을 곱하고 다시 동일한 숫자로 나누는 전략은 오류를 줄여주긴 하지만 완전히 없애지는 못한다.

구현을 하다 보면 무한 소수가 나오는 경우를 완전히 차단해야 하는 경우가 생기곤 한다. 달러가 아닌 센트 단위로 물품 가격을 저장하는 쇼핑몰을 담당하고 있는데, 행사 때문에 가격을 30% 할인해야 하는 경우가 그렇다. 무한소수를 방지하는 완벽한 방법은 사실 없다. 필요할 때마다 '꼬리’를 잘라 어림수를 만드는 방법뿐이다.



**흥미로운 발견**

```javascript
// 숫자가 스스로 증가한다!
alert( 9999999999999999 ); // 10000000000000000이 출력된다.
```

문제의 원인은 역시나 정밀도 손실 때문이다. 숫자를 저장할 땐 64비트가 사용되는데, 이 중 실제 숫자를 저장하는 데 사용되는 52비트에 위 숫자를 저장하기엔 공간이 모자란다. 따라서 최소 유효 숫자(the least significant digit)가 손실되어 버렸다.

자바스크립트는 숫자 손실이 일어나도 오류를 발생시키지 않는다. 적절한 포맷으로 숫자를 맞추는 데 최선을 다하긴 하지만 유감스럽게도 위 예시의 숫자를 담기엔 포맷이 충분하지 못한다.

**두 종류의 0**

자바스크립트 내부에서 숫자를 표현하는 방식 때문에 발생하는 또 다른 흥미로운 현상은 `0`과 `-0`이라는 두 종류의 0이 존재한다는 사실이다. 자바스크립트에선 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설정할 수도, 설정하지 않을 수도 있기 때문이다.

하지만, 대부분의 연산은 `0`과 `-0`을 동일하게 취급하기 때문에 두 0의 차이는 두드러지지 않는 편이다.



#### isNaN과 isFinite

- `Infinity`와 `-Infinity` – 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값
- `NaN` – 에러를 나타내는 값

두 특수 숫자는 `숫자형`에 속하지만 ‘정상적인’ 숫자는 아니기 때문에, 정상적인 숫자와 구분하기 위한 특별한 함수가 존재한다.

- `isNaN(value)` – 인수를 숫자로 변환한 다음 `NaN`인지 테스트함

  ```javascript
  alert( isNaN(NaN) ); // true
  alert( isNaN("str") ); // true
  ```

  그런데 굳이 이 함수가 필요할까? "`=== NaN` 비교를 하면 되지 않을까?"라는 생각이 들 수 있다. 안타깝게도 대답은 '필요하다’이다. `NaN`은 `NaN` 자기 자신을 포함하여 그 어떤 값과도 같지 않다는 점에서 독특하다.

  ```javascript
  alert( NaN === NaN ); // false
  ```

- `isFinite(value)` – 인수를 숫자로 변환하고 변환한 숫자가 `NaN/Infinity/-Infinity`가 아닌 일반 숫자인 경우 `true`를 반환함

  ```javascript
  alert( isFinite("15") ); // true
  alert( isFinite("str") ); // false, NaN이기 때문이다.
  alert( isFinite(Infinity) ); // false, Infinity이기 때문이다.
  ```

`isFinite`는 문자열이 일반 숫자인지 검증하는 데 사용되곤 한다.

```javascript
let num = +prompt("숫자를 입력하세요.", '');

// 숫자가 아닌 값을 입력하거나 Infinity, -Infinity를 입력하면 false가 출력된다.
alert( isFinite(num) );
```

빈 문자열이나 공백만 있는 문자열은 `isFinite`를 포함한 모든 숫자 관련 내장 함수에서 `0`으로 취급된다는 점에 유의하자.



> **`Object.is`와 비교하기**
>
> `Object.is` 는 `===`처럼 값을 비교할 때 사용되는 특별한 내장 메서드인데, 아래와 같은 두 가지 에지 케이스에선 `===`보다 좀 더 신뢰할만한 결과를 보여준다.
>
> 1. `Na다ㄴ`을 대상으로 비교할 때: `Object.is(NaN, NaN) === true`임.
> 2. `0`과 `-0`이 다르게 취급되어야 할 때: `Object.is(0, -0) === false`임. 숫자를 나타내는 비트가 모두 0이더라도 부호를 나타내는 비트는 다르므로 `0`과 `-0`은 사실 다른 값이긴 한다.
>
> 이 두 에지 케이스를 제외하곤, `Object.is(a, b)`와 `a === b`의 결과는 같다.
>
> 이런 식의 비교는 자바스크립트 명세서에서 종종 찾아볼 수 있다. 내부 알고리즘에서 두 값을 비교해야 하는데, 비교 결과가 정확해야 하는 경우 `Object.is`를 사용한다. `Object.is`에서 사용되는 비교방식은 명세서에서 [SameValue](https://tc39.github.io/ecma262/#sec-samevalue)라고 불린다.





#### parseInt와 parseFloat

단항 덧셈 연산자 `+` 또는 `Number()`를 사용하여 숫자형으로 변형할 때 적용되는 규칙은 꽤 엄격하다. 피연산자가 숫자가 아니면 형 변환이 실패한다.

```javascript
alert( +"100px" ); // NaN
```

엄격한 규칙이 적용되지 않는 유일한 예외는 문자열의 처음 또는 끝에 공백이 있어서 공백을 무시할 때이다.

그런데 실무에선 CSS 등에서 `'100px'`, `'12pt'`와 같이 숫자와 단위를 함께 쓰는 경우가 흔하다. 대다수 국가에서 `'19€'`처럼 금액 뒤에 통화 기호를 붙여 표시하기도 하죠. 숫자만 추출하는 방법이 필요해 보인다.

내장 함수 `parseInt`와 `parseFloat`는 이런 경우를 위해 만들어졌다.

두 함수는 불가능할 때까지 문자열에서 숫자를 ‘읽습니다’. 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환한다. `parseInt`는 정수, `parseFloat`는 부동 소수점 숫자를 반환한다.

```javascript
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, 정수 부분만 반환됩니다.
alert( parseFloat('12.3.4') ); // 12.3, 두 번째 점에서 숫자 읽기를 멈춘다.
```

`parseInt`와 `parseFloat`가 `NaN`을 반환할 때도 있습니다. 읽을 수 있는 숫자가 없을 때 그렇다.

```javascript
alert( parseInt('a123') ); // NaN, a는 숫자가 아니므로 숫자를 읽는 게 중지된다.
```

**`parseInt(str, radix)`의 두 번째 인수**

`parseInt()`의 두 번째 매개 변수는 선택적으로 사용할 수 있다. `radix`는 원하는 진수를 지정해 줄 때 사용한다. 따라서 `parseInt`를 사용하면 16진수 문자열, 2진수 문자열 등을 파싱할 수 있다.

```javascript
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, 0x가 없어도 동작한다.

alert( parseInt('2n9c', 36) ); // 123456
```





#### 기타 수학 함수

자바스크립트에서 제공하는 내장 객체 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math)엔 다양한 수학 관련 함수와 상수들이 들어있다.

몇 가지 예시를 살펴보자.

- `Math.random()`

  0과 1 사이의 난수를 반환한다(1은 제외).

  `alert( Math.random() ); // 0.1234567894322 alert( Math.random() ); // 0.5435252343232 alert( Math.random() ); // ... (무작위 수)`

- `Math.max(a, b, c...)` / `Math.min(a, b, c...)`

  인수 중 최대/최솟값을 반환한다.

  `alert( Math.max(3, 5, -10, 0, 1) ); // 5 alert( Math.min(1, 2) ); // 1`

- `Math.pow(n, power)`

  `n`을 power번 거듭제곱한 값을 반환한다.`alert( Math.pow(2, 10) ); // 2의 10제곱 = 1024`
  
  

이 외에도 삼각법을 포함한 다양한 함수와 상수가 `Math`에 있다. 





>#### 요약
>
>0이 많이 붙은 큰 숫자는 다음과 같은 방법을 사용해 쓴다.
>
>- 0의 개수를 `'e'` 뒤에 추가한다. `123e6`은 0이 6개인 숫자, `123000000`을 나타낸다.
>
>- `'e'` 다음에 음수가 오면, 음수의 절댓값 만큼 10을 거듭제곱한 숫자로 주어진 숫자를 나눈다. `123e-6`은 `0.000123`을 나타낸다.
>
>  
>
>다양한 진법을 사용할 수도 있다.
>
>- 자바스크립트는 특별한 변환 없이 16진수(`0x`), 8진수(`0o`), 2진수(`0b`)를 바로 사용할 수 있게 지원한다.
>
>- `parseInt(str, base)`를 사용하면 `str`을 `base`진수로 바꿔준다(단, `2 ≤ base ≤ 36`).
>
>- `num.toString(base)`는 숫자를 `base`진수로 바꾸고, 이를 문자열 형태로 반환한다.
>
>  
>
>`12pt`나 `100px`과 같은 값을 숫자로 변환하는 것도 가능하다.
>
>- `parseInt/parseFloat`를 사용하면 문자열에서 숫자만 읽고, 읽은 숫자를 에러가 발생하기 전에 반환해주는 ‘약한’ 형 변환을 사용할 수 있다.
>
>  
>
>소수를 처리하는 데 쓰이는 메서드는 다음과 같다.
>
>- `Math.floor`, `Math.ceil`, `Math.trunc`, `Math.round`, `num.toFixed(precision)`를 사용하면 어림수를 구할 수 있다.
>
>- 소수를 다룰 땐 정밀도 손실에 주의해야한다.
>
>  
>
>이 외에도 다양한 수학 함수가 있다.
>
>- 수학 연산이 필요할 때 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 객체를 찾아보자. 작은 객체이지만 기본적인 연산은 대부분 다룰 수 있다.











## 5.3 문자열

자바스크립트엔 글자 하나만 저장할 수 있는 별도의 자료형이 없다. 텍스트 형식의 데이터는 길이에 상관없이 문자열 형태로 저장되는데, 문자열은 페이지 인코딩 방식과 상관없이 항상 [UTF-16](https://en.wikipedia.org/wiki/UTF-16) 형식을 따른다.



#### 따옴표

따옴표의 종류가 무엇이 있었는지 상기해보자. 문자열은 작은따옴표나 큰따옴표, 백틱으로 감쌀 수 있다.

```javascript
let single = '작은따옴표';
let double = "큰따옴표";

let backticks = `백틱`;
```





작은따옴표와 큰따옴표는 기능상 차이가 없지만 백틱엔 특별한 기능이 있다. 표현식을 `${…}`로 감싸고 이를 백틱으로 감싼 문자열 중간에 넣어주면 해당 표현식을 문자열 중간에 쉽게 삽입할 수 있다. 이런 방식을 **템플릿 리터럴(template literal)**이라고 부른다.

```javascript
function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
```



백틱을 사용하면 문자열을 여러 줄에 걸쳐 작성할 수도 있다.

```javascript
let guestList = `손님:
 * John
 * Pete
 * Mary
`;

alert(guestList); // 손님 리스트를 여러 줄에 걸쳐 작성함
```



자연스럽게 여러 줄의 문자열이 만들어졌다. 하지만 작은따옴표나 큰따옴표를 사용하면 위와 같은 방식으로 여러 줄짜리 문자열을 만들 수 없다. 아래 예시를 실행해보면 에러가 발생한다.

```javascript
let guestList = "손님: // Error: Invalid or unexpected token
  * John";
```



작은따옴표나 큰따옴표로 문자열을 표현하는 방식은 자바스크립트가 만들어졌을 때부터 있었지만, 이때는 문자열을 여러 줄에 걸쳐 작성할 생각조차 못 했던 시기였다. 백틱은 그 이후에 등장한 문법이기 때문에 따옴표보다 다양한 기능을 제공한다.

**백틱은 '템플릿 함수(template function)'에서도 사용된다.**  func``stri같이 첫 번째 백틱 바로 앞에 함수 이름(`func)을 써주면, 이 함수는 백틱 안의 문자열 조각이나 표현식 평가 결과를 인수로 받아 자동으로 호출된다. 이런 기능을 **'태그드 템플릿(tagged template)'**이라 부르는데, 태그드 템플릿을 사용하면 사용자 지정 템플릿에 맞는 문자열을 쉽게 만들 수 있는데 잘 사용되진 않는다. 







#### 특수 기호

'줄 바꿈 문자(newline character)'라 불리는 특수기호 `\n`을 사용하면 작은따옴표나 큰따옴표로도 여러 줄 문자열을 만들 수 있다.

```javascript
let guestList = "손님:\n * John\n * Pete\n * Mary";

alert(guestList); // 손님 리스트를 여러 줄에 걸쳐 작성함
```



따옴표를 이용해 만든 여러 줄 문자열과 백틱을 이용해 만든 여러 줄 문자열은 표현 방식만 다를 뿐 차이가 없다.

```javascript
let str1 = "Hello\nWorld"; // '줄 바꿈 기호'를 사용해 두 줄짜리 문자열을 만듦

// 백틱과 일반적인 줄 바꿈 방법(엔터)을 사용해 두 줄짜리 문자열을 만듦
let str2 = `Hello
World`;

alert(str1 == str2); // true
```



자바스크립트엔 줄 바꿈 문자를 비롯한 다양한 ‘특수’ 문자들이 있다.

특수 문자 목록:

| 특수 문자                                            | 설명                                                         |
| :--------------------------------------------------- | :----------------------------------------------------------- |
| `\n`                                                 | 줄 바꿈                                                      |
| `\r`                                                 | 캐리지 리턴(carriage return). Windows에선 캐리지 리턴과 줄 바꿈 특수 문자를 조합(`\r\n`)해 줄을 바꾼다. 캐리지 리턴을 단독으론 사용하는 경우는 없다. |
| `\'`, `\"`                                           | 따옴표                                                       |
| `\\`                                                 | 역슬래시                                                     |
| `\t`                                                 | 탭                                                           |
| `\b`, `\f`, `\v`                                     | 각각 백스페이스(Backspace), 폼 피드(Form Feed), 세로 탭(Vertical Tab)을 나타낸다. 호환성 유지를 위해 남아있는 기호로 요즘엔 사용하지 않는다. |
| `\xXX`                                               | 16진수 유니코드 `XX`로 표현한 유니코드 글자이다(예시: 알파벳 `'z'`는 `'\x7A'`와 동일함). |
| `\uXXXX`                                             | UTF-16 인코딩 규칙을 사용하는 16진수 코드 `XXXX`로 표현한 유니코드 기호이다. `XXXX`는 반드시 네 개의 16진수로 구성되어야 한다(예시: `\u00A9`는 저작권 기호 `©`의 유니코드임). |
| `\u{X…XXXXXX}`(한 개에서 여섯 개 사이의 16진수 글자) | UTF-32로 표현한 유니코드 기호이다. 몇몇 특수한 글자는 두 개의 유니코드 기호를 사용해 인코딩되므로 4바이트를 차지한다. 이 방법을 사용하면 긴 코드를 삽입할 수 있다. |



유니코드를 사용한 예시:

```javascript
alert( "\u00A9" ); // ©
alert( "\u{20331}" ); // 佫, 중국어(긴 유니코드)
alert( "\u{1F60D}" ); // 😍, 웃는 얼굴 기호(긴 유니코드)
```

**모든 특수 문자는 '이스케이프 문자(escape character)'라고도 불리는 역슬래시 (backslash character) `\`로 시작한다.**

역슬래시는 문자열 내에 따옴표를 넣을 때도 사용할 수 있다.



```javascript
alert( 'I\'m the Walrus!' ); // I'm the Walrus!
```

위 예시에서 살펴본 바와 같이 문자열 내의 따옴표엔 `\`를 꼭 붙여줘야 한다. 이렇게 하지 않으면 자바스크립트는 해당 따옴표가 문자열을 닫는 용도로 사용된 것이라 해석하기 때문이다.



이스케이프 문자는 문자열을 감쌀 때 사용한 따옴표와 동일한 따옴표에만 붙여주면 된다. 문자열 내에서 좀 더 우아하게 따옴표를 사용하려면 아래와 같이 따옴표 대신 백틱으로 문자열을 감싸주면 된다.

```javascript
alert( `I'm the Walrus!` ); // I'm the Walrus!
```

역슬래시 `\`는 문자열을 정확하게 읽기 위한 용도로 만들어졌으므로 `\`는 제 역할이 끝나면 사라진다. 메모리에 저장되는 문자열엔 `\`가 없습니다. 앞선 예시들을 실행했을 때 뜨는 `alert` 창을 통해 이를 확인할 수 있다.



그렇다면 문자열 안에 역슬래시 `\`를 보여줘야 하는 경우엔 어떻게 해야 할까?

`\\`같이 역슬래시를 두 개 붙이면 된다.

```javascript
alert( `역슬래시: \\` ); // 역슬래시: \
```





#### 문자열의 길이

`length` 프로퍼티엔 문자열의 길이가 저장된다.

```javascript
alert( `My\n`.length ); // 3
```

`\n`은 ‘특수 문자’ 하나로 취급되기 때문에 `My\n`의 길이는 `3`이다.

**`length`는 프로퍼티이다.**

자바스크립트 이외의 언어를 사용했던 개발자들은 `str.length`가 아닌 `str.length()`로 문자열의 길이를 알아내려고 하는 경우가 있다. 하지만 원하는 대로 동작하지 않는다.

`length`는 함수가 아니며, 숫자가 저장되는 프로퍼티기 때문에 뒤에 괄호를 붙일 필요가 없다는 점에 주의하자. 





#### 특정 글자에 접근하기

문자열 내 특정 위치인 `pos`에 있는 글자에 접근하려면 `[pos]`같이 대괄호를 이용하거나 [str.charAt(pos)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/charAt)라는 메서드를 호출하면 된다. 위치는 0부터 시작한다.

```javascript
let str = `Hello`;

// 첫 번째 글자
alert( str[0] ); // H
alert( str.charAt(0) ); // H

// 마지막 글자
alert( str[str.length - 1] ); // o
```

근래에는 대괄호를 이용하는 방식을 사용한다. `charAt`은 하위 호환성을 위해 남아있는 메서드라고 생각하면 된다.



**두 접근 방식의 차이는 반환할 글자가 없을 때 드러난다.** 접근하려는 위치에 글자가 없는 경우 `[]`는 `undefined`를, `charAt`은 빈 문자열을 반환한다.

```javascript
let str = `Hello`;

alert( str[1000] ); // undefined
alert( str.charAt(1000) ); // '' (빈 문자열)
```



`for..of`를 사용하면 문자열을 구성하는 글자를 대상으로 반복 작업을 할 수 있다.

```javascript
for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char는 순차적으로 H, e, l, l, o가 된다.)
}
```





#### 문자열의 불변성

**문자열은 수정할 수 없다.** 따라서 문자열의 중간 글자 하나를 바꾸려고 하면 에러가 발생한다.

```javascript
let str = 'Hi';

str[0] = 'h'; // Error: Cannot assign to read only property '0' of string 'Hi'
alert( str[0] ); // 동작하지 않는다.
```



이런 문제를 피하려면 완전히 새로운 문자열을 하나 만든 다음, 이 문자열을 `str`에 할당하면 된다.

```javascript
let str = 'Hi';

str = 'h' + str[1]; // 문자열 전체를 교체함

alert( str ); // hi
```





#### 대·소문자 변경하기

메서드 [toLowerCase()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase)와 [toUpperCase()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase)는 대문자를 소문자로, 소문자를 대문자로 변경(케이스 변경)시켜준다.

```javascript
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface
```

글자 하나의 케이스만 변경하는 것도 가능하다.

```javascript
alert( 'Interface'[0].toLowerCase() ); // 'i'
```



#### 부분 문자열 찾기

문자열에서 부분 문자열(substring)을 찾는 방법은 여러 가지가 있다.



#### str.indexOf

첫 번째 방법은 [str.indexOf(substr, pos)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf) 메서드를 이용하는 것이다.

이 메서드는 문자열 `str`의 `pos`에서부터 시작해, 부분 문자열 `substr`이 어디에 위치하는지를 찾아준다. 원하는 부분 문자열을 찾으면 위치를 반환하고 그렇지 않으면 `-1`을 반환한다.



```javascript
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, str은 'Widget'으로 시작함
alert( str.indexOf('widget') ); // -1, indexOf는 대·소문자를 따지므로 원하는 문자열을 찾지 못함

alert( str.indexOf("id") ); // 1, "id"는 첫 번째 위치에서 발견됨 (Widget에서 id)
```

`str.indexOf(substr, pos)`의 두 번째 매개변수 `pos`는 선택적으로 사용할 수 있는데, 이를 명시하면 검색이 해당 위치부터 시작된다.

부분 문자열 `"id"`는 위치 `1`에서 처음 등장하는데, 두 번째 인수에 `2`를 넘겨 `"id"`가 두 번째로 등장하는 위치가 어디인지 알아보자.

```javascript
let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
```

문자열 내 부분 문자열 전체를 대상으로 무언가를 하고 싶다면 반복문 안에 `indexOf`를 사용하면 된다. 반복문이 하나씩 돌 때마다 검색 시작 위치가 갱신되면서 `indexOf`가 새롭게 호출된다.

```javascript
let str = 'As sly as a fox, as strong as an ox';

let target = 'as'; // as를 찾아보자.

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `위치: ${foundPos}` );
  pos = foundPos + 1; // 다음 위치를 기준으로 검색을 이어간다.
}
```

동일한 알고리즘을 사용해 코드만 짧게 줄이면 다음과 같다.

```javascript
let str = "As sly as a fox, as strong as an ox";
let target = "as";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( `위치: ${pos}` );
}
```

**`str.lastIndexOf(substr, position)`**

[str.lastIndexOf(substr, position)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf)는 `indexOf`와 유사한 기능을 하는 메서드이다. 문자열 끝에서부터 부분 문자열을 찾는다는 점만 다르다.

반환되는 부분 문자열 위치는 문자열 끝이 기준이다.

`if`문의 조건식에 `indexOf`를 쓸 때 주의할 점이 하나 있다. 아래와 같이 코드들 작성하면 원하는 결과를 얻을 수 없다.

```javascript
let str = "Widget with id";

if (str.indexOf("Widget")) {
    alert("찾았다!"); // 의도한 대로 동작하지 않는다.
}
```

`str.indexOf("Widget")`은 `0`을 반환하는데, `if`문에선 `0`을 `false`로 간주하므로 `alert` 창이 뜨지 않는다.

따라서 부분 문자열 여부를 검사하려면 아래와 같이 `-1`과 비교해야 한다.

```javascript
let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
    alert("찾았다!"); // 의도한 대로 동작한다.
}
```





#### 비트 NOT 연산자를 사용한 기법

비트 NOT 연산자는 피연산자를 32비트 정수로 바꾼 후(소수부는 모두 버려짐) 모든 비트를 반전한다.

따라서 `n`이 32비트 정수일 때 `~n`은 `-(n+1)`이 된다.

```javascript
alert( ~2 ); // -3, -(2+1)과 같음
alert( ~1 ); // -2, -(1+1)과 같음
alert( ~0 ); // -1, -(0+1)과 같음
alert( ~-1 ); // 0, -(-1+1)과 같음
```

위 예시에서 본 바와 같이 부호가 있는 32비트 정수 `n` 중, `~n`을 `0`으로 만드는 경우는 `n == -1`일 때가 유일하다.

이를 응용해서 `indexOf`가 `-1`을 반환하지 않는 경우를 `if ( ~str.indexOf("...") )`로 검사해 보자.

이렇게 `~str.indexOf("...")`를 사용하면 코드의 길이를 줄일 수 있다.

```javascript
let str = "Widget";

if (~str.indexOf("Widget")) {
  alert( '찾았다!' ); // 의도한 대로 동작한다.
}
```

사실 이렇게 언어 특유의 기능을 사용해 직관적이지 않은 코드를 작성하는 것을 추천해 드리진 않는다. 그렇지만 위와 같은 기법은 오래된 스크립트에서 쉽게 만날 수 있기 때문에 알아두어야 한다.

`if (~str.indexOf(...))` 패턴의 코드를 만나면 '부분 문자열인지 확인’하는 코드라고 기억해주자.

참고로 `-1` 이외에도 `~` 연산자 적용 시 `0`을 반환하는 숫자는 다양하다. 아주 큰 숫자에 `~` 연산자를 적용하면 32비트 정수로 바꾸는 과정에서 잘림 현상이 발생하기 때문이다. 이런 숫자 중 가장 큰 숫자는 `4294967295`입니다(`~4294967295`는 `0`임). 문자열이 아주 길지 않은 경우에만 `~` 연산자가 의도한 대로 작동한다는 점을 알고 있자.

모던 자바스크립트에선 `.includes` 메서드(아래에서 배움)를 사용해 부분 문자열 포함 여부를 검사한다. 이런 기법은 오래된 자바스크립트에서만 볼 수 있다.



#### includes, startsWith, endsWith

비교적 근래에 나온 메서드인 [str.includes(substr, pos)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/includes)는 `str`에 부분 문자열 `substr`이 있는지에 따라 `true`나 `false`를 반환한다.

부분 문자열의 위치 정보는 필요하지 않고 포함 여부만 알고 싶을 때 적합한 메서드이다.

```javascript
alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
```

`str.includes`에도 `str.indexOf`처럼 두 번째 인수를 넘기면 해당 위치부터 부분 문자열을 검색한다.

```javascript
alert( "Widget".includes("id") ); // true
alert( "Widget".includes("id", 3) ); // false, 세 번째 위치 이후엔 "id"가 없다.
```

메서드 [str.startsWith](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith)와 [str.endsWith](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith)는 메서드 이름 그대로 문자열 `str`이 특정 문자열로 시작하는지(start with) 여부와 특정 문자열로 끝나는지(end with) 여부를 확인할 때 사용할 수 있다.

```javascript
alert( "Widget".startsWith("Wid") ); // true, "Widget"은 "Wid"로 시작한다.
alert( "Widget".endsWith("get") ); // true, "Widget"은 "get"으로 끝난다.
```





#### 부분 문자열 추출하기

자바스크립트엔 부분 문자열 추출과 관련된 메서드가 세 가지 있다. 세 가지 메서드 `substring`, `substr`, `slice`를 하나씩 알아보자.

- `str.slice(start [, end])`  / 문자열의 `start`부터 `end`까지(`end`는 미포함)를 반환한다

  ```javascript
  let str = "stringify"; 
  alert( str.slice(0, 5) ); // 'strin', 0번째부터 5번째 위치까지(5번째 위치의 글자는 포함하지 않음) 
  alert( str.slice(0, 1) ); // 's', 0번째부터 1번째 위치까지(1번째 위치의 자는 포함하지 않음)
  ```

  

  두 번째 인수가 생략된 경우엔, 명시한 위치부터 문자열 끝까지를 반환한다.

  ```javascript
  let str = "stringify";
  alert( str.slice(2) ); // ringify, 2번째부터 끝까지
  ```

  `start`와 `end`는 음수가 될 수도 있습니다. 음수를 넘기면 문자열 끝에서부터 카운팅을 시작한다.

  ```javascript
  let str = "stringify";
  
  // 끝에서 4번째부터 시작해 끝에서 1번째 위치까지
  alert( str.slice(-4, -1) ); // gif]
  ```



* `str.substring(start [, end])`  / `start`와 `end` *사이*에 있는 문자열을 반환한다.

  `substring`은 `slice`와 아주 유사하지만 `start`가 `end`보다 커도 괜찮다는 데 차이가 있다.

  ```javascript
  let str = "stringify";
  
  // 동일한 부분 문자열을 반환한다.
  alert( str.substring(2, 6) ); // "ring"
  alert( str.substring(6, 2) ); // "ring"
  
  // slice를 사용하면 결과가 다르다.
  alert( str.slice(2, 6) ); // "ring" (같음)
  alert( str.slice(6, 2) ); // "" (빈 문자열)
  ```

  `substring`은 음수 인수를 허용하지 않습니다. 음수는 `0`으로 처리된다.

  

* `str.substr(start [, length])`  / `start`에서부터 시작해 `length` 개의 글자를 반환한다.

  `substr`은 끝 위치 대신에 길이를 기준으로 문자열을 추출한다는 점에서 `substring`과 `slice`와 차이가 있다.

  ```javascript
  let str = "stringify";
  alert( str.substr(2, 4) ); // ring, 두 번째부터 글자 네 개
  첫 번째 인수가 음수면 뒤에서부터 개수를 센다.
  
  let str = "stringify";
  alert( str.substr(-4, 2) ); // gi, 끝에서 네 번째 위치부터 글자 두 개
  ```

  

부분 문자열 추출과 관련된 메서드를 요약해 보자.

| 메서드                  | 추출할 부분 문자열                    | 음수 허용 여부(인수)  |
| :---------------------- | :------------------------------------ | :-------------------- |
| `slice(start, end)`     | `start`부터 `end`까지(`end`는 미포함) | 음수 허용             |
| `substring(start, end)` | `start`와 `end` 사이                  | 음수는 `0`으로 취급함 |
| `substr(start, length)` | `start`부터 `length`개의 글자         | 음수 허용             |

**어떤 메서드를 선택해야 할까?**

모두 사용해도 괜찮지만, `substr`에는 단점이 하나 있다. `substr`는 코어 자바스크립트 명세서(ECMA-262 – 옮긴이)가 아닌, 구식 스크립트에 대응하기 위해 남겨 둔 브라우저 전용 기능들을 명시해 놓은 부록 B(Annex B)에 정의되어있다. 거의 모든 곳에서 이 메서드가 동작하긴 하지만 브라우저 이외의 호스트 환경에서는 제대로 동작하지 않을 수 있다.

남은 두 메서드 중 `slice`는 음수 인수를 허용한다는 측면에서 `substring`보다 좀 더 유연하다. 메서드 이름도 더 짧기 때문에 세 메서드 중 `slice`만 외워놓고 사용해도 충분할 것 같다.





#### 문자열 비교하기

[비교 연산자](https://ko.javascript.info/comparison) 챕터에서 알아보았듯이 문자열을 비교할 땐 알파벳 순서를 기준으로 글자끼리 비교가 이뤄진다.

그런데 아래와 같이 몇 가지 이상해 보이는 것들이 있다.

1. 소문자는 대문자보다 항상 크다.

   ```javascript
   alert( 'a' > 'Z' ); // true
   ```

2. 발음 구별 기호(diacritical mark)가 붙은 문자는 알파벳 순서 기준을 따르지 않다.

   ```javascript
   alert( 'Österreich' > 'Zealand' ); // true (Österreich는 오스트리아를 독일어로 표기한 것임 - 옮긴이)
   ```

   이런 예외사항 때문에 이름순으로 국가를 나열할 때 예상치 못한 결과가 나올 수 있다. 사람들은 `Österreich`가 `Zealand`보다 앞서 나올 것이라 예상하는데 그렇지 않다.
   
   

자바스크립트 내부에서 문자열이 어떻게 표시되는지 상기하며 원인을 알아보자.

모든 문자열은 [UTF-16](https://en.wikipedia.org/wiki/UTF-16)을 사용해 인코딩되는데, UTF-16에선 모든 글자가 숫자 형식의 코드와 매칭된다. 코드로 글자를 얻거나 글자에서 연관 코드를 알아낼 수 있는 메서드는 다음과 같다.

- `str.codePointAt(pos)`

  `pos`에 위치한 글자의 코드를 반환한다.`// 글자는 같지만 케이스는 다르므로 반환되는 코드가 다르다. alert( "z".codePointAt(0) ); // 122 alert( "Z".codePointAt(0) ); // 90`

- `String.fromCodePoint(code)`

  숫자 형식의 `code`에 대응하는 글자를 만들어준다.`alert( String.fromCodePoint(90) ); // Z``\u` 뒤에 특정 글자에 대응하는 16진수 코드를 붙이는 방식으로도 원하는 글자를 만들 수 있다.`// 90을 16진수로 변환하면 5a이다. alert( '\u005a' ); // Z`
  
  

이제 이 배경지식을 가지고 코드 `65`와 `220` 사이(라틴계열 알파벳과 기타 글자들이 여기에 포함됨)에 대응하는 글자들을 출력해보자.

```javascript
let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
```

대문자 알파벳이 가장 먼저 나오고 특수 문자 몇 개가 나온 다음에 소문자 알파벳이 나오고 `Ö`은 거의 마지막에 출력된다.

이제 왜 `a > Z`인지 알수 있나?

글자는 글자에 대응하는 숫자 형식의 코드를 기준으로 비교된다. 코드가 크면 대응하는 글자 역시 크다고 취급된다. 따라서 `a`(코드:97)는 `Z`(코드:90) 보다 크다는 결론이 도출된다.

- 알파벳 소문자의 코드는 대문자의 코드보다 크므로 소문자는 대문자 뒤에 온다.
- `Ö` 같은 글자는 일반 알파벳과 멀리 떨어져 있습니다. `Ö`의 코드는 알파벳 소문자의 코드보다 훨씬 크다.



#### 문자열 제대로 비교하기

언어마다 문자 체계가 다르기 때문에 문자열을 ‘제대로’ 비교하는 알고리즘을 만드는 건 생각보다 간단하지 않다.

문자열을 비교하려면 일단 페이지에서 어떤 언어를 사용하고 있는지 브라우저가 알아야 한다.

다행히도 모던 브라우저 대부분이 국제화 관련 표준인 [ECMA-402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf)를 지원한다(IE10은 아쉽게도 [Intl.js](https://github.com/andyearnshaw/Intl.js/) 라이브러리를 사용해야 합니다).

ECMA-402엔 언어가 다를 때 적용할 수 있는 문자열 비교 규칙과 이를 준수하는 메서드가 정의되어있다.

[str.localeCompare(str2)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)를 호출하면 ECMA-402에서 정의한 규칙에 따라 `str`이 `str2`보다 작은지, 같은지, 큰지를 나타내주는 정수가 반환된다.

- `str`이 `str2`보다 작으면 음수를 반환한다.
- `str`이 `str2`보다 크면 양수를 반환한다.
- `str`과 `str2`이 같으면 `0`을 반환한다.



```javascript
alert( 'Österreich'.localeCompare('Zealand') ); // -1
```

`localeCompare`엔 선택 인수 두 개를 더 전달할 수 있다. 기준이 되는 언어를 지정(아무것도 지정하지 않았으면 호스트 환경의 언어가 기준 언어가 됨)해주는 인수와 대·소문자를 구분할지나 `"a"`와 `"á"`를 다르게 취급할지에 대한 것을 설정해주는 인수가 더 있다. 







#### 1. 문자열 심화(Optional)

##### 1.1 서로게이트 쌍

자주 사용되는 글자들은 모두 2바이트 코드를 가지고 있다. 유럽권 언어에서 사용되는 글자, 숫자, 상형 문자 대다수는 2바이트 표현 체계를 사용한다.

그런데 2바이트는 65,536(2의 16승 – 옮긴이)개의 조합밖에 만들어내지 못하기 때문에 현존하는 기호를 모두 표현하기에 충분하지 않다. 이를 극복하기 위해 사용 빈도가 낮은 기호는 '서로게이트 쌍(surrogate pair)'이라 불리는 2바이트 글자들의 쌍을 사용해 인코딩한다.

서로게이트 쌍을 사용해 인코딩한 기호의 길이는 `2`이다.

```javascript
alert( '𝒳'.length ); // 2, 수학에서 쓰이는 대문자 X(그리스 문자 카이 - 옮긴이)
alert( '😂'.length ); // 2, 웃으면서 눈물 흘리는 얼굴을 나타내는 이모티콘
alert( '𩷶'.length ); // 2, 사용 빈도가 낮은 중국어(상형문자)
```

자바스크립트가 만들어졌을 당시엔 서로게이트 쌍은 존재하지 않았다. 따라서 자바스크립트는 서로게이트 쌍으로 표현한 기호를 제대로 처리하지 못한다.

위 예시에서 기호는 하나지만 길이는 `2`인 것을 보고 의아해할 수 있는데, 이런 이유 때문이다.

`String.fromCodePoint`와 `str.codePointAt`은 명세서에 추가된 지 얼마 안 된 메서드로, 서로게이트 쌍을 제대로 처리할 수 있는 몇 안 되는 메서드 이다. 두 메서드가 등장하기 전에는 [String.fromCharCode](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode)와 [str.charCodeAt](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)을 사용했었는데, 이 메서드들은 `fromCodePoint`, `codePointAt`과 동일하게 동작하지만 서로게이트 쌍은 처리하지 못한다.

서로게이트 쌍은 두 글자로 취급되기 때문에 기호를 가져오는 게 꽤 까다롭다.

```javascript
alert( '𝒳'[0] ); // 이상한 기호가 출력됨
alert( '𝒳'[1] ); // 서로게이트 쌍의 일부가 출력됨
```

서로게이트 쌍을 구성하는 글자들은 붙어있을 때만 의미가 있다는 점에 유의해야 한다. 따라서 위 예시를 실행하면 얼럿창엔 의미 없는 쓰레기 기호가 출력된다.

기술적으로 서로게이트 쌍은 서로게이트 쌍에 대응하는 코드를 사용해 감지할 수 있다. 글자의 코드가 `0xd800..0xdbff` 사이에 있으면 이 코드는 서로게이트 쌍을 구성하는 첫 번째 글자를 나타낸다는 것을 알 수 있다. 이 경우 서로게이트 쌍을 구성하는 두 번째 글자의 코드는 반드시 `0xdc00..0xdfff` 사이에 있어야 한다. 범위 `0xd800..0xdbff`와 `0xdc00..0xdfff`는 표준에서 서로게이트 쌍을 위해 일부러 비워둔 코드이다.



```javascript
// charCodeAt는 서로게이트 쌍을 처리하지 못하기 때문에 서로게이트 쌍을 구성하는 부분에 대한 코드를 반환한다.

alert( '𝒳'.charCodeAt(0).toString(16) ); // d835, 0xd800과 0xdbff 사이의 코드
alert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3, 0xdc00과 0xdfff 사이의 코드
```

서로게이트 쌍을 다루는 다양한 방법에 대해선 [iterable 객체](https://ko.javascript.info/iterable) 챕터에서 살펴보겠다. 서로게이트 쌍 관련 라이브러리도 있긴 한데 소개해 드릴 만한 라이브러리는 아직까진 없는 상황이다.



##### 1.2 발음 구별 기호와 유니코드 정규화

여러 언어에서 베이스가 되는 글자 위나 아래에 발음 구별 기호라 불리는 기호를 붙여 글자를 만듭니다.

`a`를 베이스 글자로, `àáâäãåā`를 만드는 것 같이 말이다. 이런 ‘합성’ 글자 대부분은 UTF-16 테이블에서 독자적인 코드를 갖는다. 그런데 모든 합성 글자에 코드가 부여되지는 않다. 조합 가능한 글자의 수가 너무 많기 때문다.

임의의 조합을 지원하기 위해 UTF-16에선 몇 개의 유니코드 문자를 남겨두었다. 베이스 글자 뒤에 하나 혹은 여러 개의 유니코드 문자를 붙여 베이스 글자를 꾸밀 수 있도록 말이다.

이를 이용하면 베이스 글자 `S` 뒤에 '윗 점’을 나타내는 유니코드 문자(`\u0307`)를 붙여 Ṡ를 만들 수 있다.

```javascript
alert( 'S\u0307' ); // Ṡ
```

발음 구별 기호를 하나 붙인 상태에서 추가 발음 구별 기호가 필요한 경우에도 문제가 없다. 필요한 기호의 유니코드 문자를 붙여주기만 하면 된다.

Ṡ에 '아래 점’을 나타내는 유니코드 문자(`\u0323`)를 추가해서 ‘S 위와 아래에 점이 붙게’ 해보자.

```javascript
alert( 'S\u0307\u0323' ); // Ṩ
```

이런 방식은 엄청난 유연성을 제공하는데, 단점도 있다. 눈으로 봤을 때는 같은 글자인데 유니코드 조합이 다른 경우가 생긴다.



```javascript
let s1 = 'S\u0307\u0323'; // Ṩ, S + 윗 점 + 아랫 점
let s2 = 'S\u0323\u0307'; // Ṩ, S + 아랫 점 + 윗 점

alert( `s1: ${s1}, s2: ${s2}` );

alert( s1 == s2 ); // 눈으로 보기엔 같은 글자이지만 동등 비교 시 false가 반환된다.
```

이런 문제를 해결하려면 '유니코드 정규화(unicode normalization)'라 불리는 알고리즘을 사용해 각 문자열을 동일한 형태로 '정규화’해야 한다.

유니코드 정규화 알고리즘은 [str.normalize()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)에 구현되어 있다.

```javascript
alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true
```

S 위, 아래에 점을 붙이는 사례에선 `normalize()`를 사용하면 세 개의 글자가 하나로 합쳐진다. `Ṩ`를 나타내는 유니코드 `\u1e68`로 말이다.

```javascript
alert( "S\u0307\u0323".normalize().length ); // 1

alert( "S\u0307\u0323".normalize() == "\u1e68" ); // true
```

그런데 현실은 항상 이렇지 않다. `Ṩ`가 하나의 유니코드로 합쳐지는 것은 UTF-16을 만드는 데 참여한 사람들이 `Ṩ`는 '충분히 나타날 수 있는 사례’라 생각하고, `Ṩ`를 UTF-16 테이블에 포함하고 코드를 부여해놓았기 때문이다.





>#### 요약
>
>- 자바스크립트엔 세 종류의 따옴표가 있는데, 이 중 하나인 백틱은 문자열을 여러 줄에 걸쳐 쓸 수 있게 해주고 문자열 중간에 `${…}`을 사용해 표현식도 넣을 수 있다는 점이 특징이다.
>- 자바스크립트에선 UTF-16을 사용해 문자열을 인코딩한다.
>- `\n` 같은 특수 문자를 사용할 수 있다. `\u...`를 사용하면 해당 문자의 유니코드를 사용해 글자를 만들 수 있다.
>- 문자열 내의 글자 하나를 얻으려면 대괄호 `[]`를 사용하자.
>- 부분 문자열을 얻으려면 `slice`나 `substring`을 사용하자.
>- 소문자로 바꾸려면 `toLowerCase`, 대문자로 바꾸려면 `toUpperCase`를 사용하자.
>- `indexOf`를 사용하면 부분 문자열의 위치를 얻을 수 있다. 부분 문자열 여부만 알고 싶다면 `includes/startsWith/endsWith`를 사용하면 된다.
>- 특정 언어에 적합한 비교 기준 사용해 문자열을 비교하려면 `localeCompare`를 사용하자. 이 메서드를 사용하지 않으면 글자 코드를 기준으로 문자열이 비교된다.
>
>이외에도 문자열에 쓸 수 있는 유용한 메서드 몇 가지가 있다.
>
>- `str.trim()` – 문자열 앞과 끝의 공백 문자를 다듬어 준다(제거함).
>- `str.repeat(n)` – 문자열을 `n`번 반복한다.









## 5.4 배열 

키를 사용해 식별할 수 있는 값을 담은 컬렉션은 객체라는 자료구조를 이용해 저장하는데, 객체만으로도 다양한 작업을 할 수 있다.

그런데 개발을 진행하다 보면 첫 번째 요소, 두 번째 요소, 세 번째 요소 등과 같이 *순서가 있는 컬렉션*이 필요할 때가 생기곤 한다. 사용자나 물건, HTML 요소 목록같이 일목요연하게 순서를 만들어 정렬하기 위해서 말이ㄷㅏ.

순서가 있는 컬렉션을 다뤄야 할 때 객체를 사용하면 순서와 관련된 메서드가 없어 그다지 편리하지 않다. 객체는 태생이 순서를 고려하지 않고 만들어진 자료구조이기 때문에 객체를 이용하면 새로운 프로퍼티를 기존 프로퍼티 ‘사이에’ 끼워 넣는 것도 불가능하다.

이럴 땐 순서가 있는 컬렉션을 저장할 때 쓰는 자료구조인 `배열`을 사용할 수 있다.



#### 배열 선언

아래 두 문법을 사용하면 빈 배열을 만들 수 있다.

```javascript
let arr = new Array();
let arr = [];
```

대부분 두 번째 방법으로 배열을 선언하는데, 이때 대괄호 안에 초기 요소를 넣어주는 것도 가능하다.

```javascript
let fruits = ["사과", "오렌지", "자두"];
```

각 배열 요소엔 0부터 시작하는 숫자(인덱스)가 매겨져 있다. 이 숫자들은 배열 내 순서를 나타낸다.

배열 내 특정 요소를 얻고 싶다면 대괄호 안에 순서를 나타내는 숫자인 인덱스를 넣어주면 된다.

```javascript
let fruits = ["사과", "오렌지", "자두"];

alert( fruits[0] ); // 사과
alert( fruits[1] ); // 오렌지
alert( fruits[2] ); // 자두
```

같은 방법으로 요소를 수정할 수 있다.

```javascript
fruits[2] = '배'; // 배열이 ["사과", "오렌지", "배"]로 바뀜
```

새로운 요소를 배열에 추가하는 것도 가능하다.

```javascript
fruits[3] = '레몬'; // 배열이 ["사과", "오렌지", "배", "레몬"]으로 바뀜
```

`length`를 사용하면 배열에 담긴 요소가 몇 개인지 알아낼 수 있다.

```javascript
let fruits = ["사과", "오렌지", "자두"];

alert( fruits.length ); // 3
```

`alert`를 사용해 요소 전체를 출력하는 것도 가능하다.

```javascript
let fruits = ["사과", "오렌지", "자두"];

alert( fruits ); // 사과,오렌지,자두
```



배열 요소의 자료형엔 제약이 없다.

```javascript
// 요소에 여러 가지 자료형이 섞여 있습니다.
let arr = [ '사과', { name: '이보라' }, true, function() { alert('안녕하세요.'); } ];

// 인덱스가 1인 요소(객체)의 name 프로퍼티를 출력한다.
alert( arr[1].name ); // 이보라

// 인덱스가 3인 요소(함수)를 실행한다.
arr[3](); // 안녕하세요.
```



**trailing 쉼표**

배열의 마지막 요소는 객체와 마찬가지로 쉼표로 끝날 수 있다.

```javascript
let fruits = [
  "사과",
  "오렌지",
  "자두",
];
```

trailing(길게 늘어지는) 쉼표를 사용하면 모든 줄의 생김새가 유사해지기 때문에 요소를 넣거나 빼기가 쉬워진다.





#### pop·push와 shift·unshift

[큐(queue)](https://en.wikipedia.org/wiki/Queue_(abstract_data_type))는 배열을 사용해 만들 수 있는 대표적인 자료구조로, 배열과 마찬가지로 순서가 있는 컬렉션을 저장하는 데 사용한다. 큐에서 사용하는 주요 연산은 아래와 같다.

- `push` – 맨 끝에 요소를 추가한다.
- `shift` – 제일 앞 요소를 꺼내 제거한 후 남아있는 요소들을 앞으로 밀어준다. 이렇게 하면 두 번째 요소가 첫 번째 요소가 된다.

배열엔 두 연산을 가능케 해주는 내장 메서드 `push`와 `pop`이 있다.

화면에 순차적으로 띄울 메시지를 비축해 놓을 자료 구조를 만들 때 큐를 사용하는 것처럼 큐는 실무에서 상당히 자주 쓰이는 자료구조다.

배열은 큐 이외에 [스택(stack)](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))이라 불리는 자료구조를 구현할 때도 쓰인다.

스택에서 사용하는 연산은 아래와 같다.

- `push` – 요소를 스택 끝에 집어넣는다.
- `pop` – 스택 끝 요소를 추출한다.

스택은 이처럼 '한쪽 끝’에 요소를 더하거나 뺄 수 있게 해주는 자료구조이다.

스택은 흔히 카드 한 벌과 비교된다. 쌓여있는 카드 맨 위에 새로운 카드를 더해주거나 빼는 것처럼 스택도 '한쪽 끝’에 요소를 집어넣거나 추출 할 수 있기 때문이다.

스택을 사용하면 가장 나중에 집어넣은 요소가 먼저 나온다. 이런 특징을 줄여서 후입선출(Last-In-First-Out, LIFO)이라고 부른다. 반면 큐를 사용하면 먼저 집어넣은 요소가 먼저 나오기 때문에 큐는 선입선출(First-In-First-Out, FIFO) 자료구조라고 부른다.

자바스크립트 배열을 사용하면 큐와 스택 둘 다를 만들 수 있다. 이 자료구조들은 배열의 처음이나 끝에 요소를 더하거나 빼는 데 사용된다.

이렇게 처음이나 끝에 요소를 더하거나 빼주는 연산을 제공하는 자료구조를 컴퓨터 과학 분야에선 [데큐(deque, Double Ended Queue)](https://en.wikipedia.org/wiki/Double-ended_queue)라고 부른다.



**아래는 배열 끝에 무언가를 해주는 메서드이다.**

- `pop`

  배열 끝 요소를 제거하고, 제거한 요소를 반환한다.`let fruits = ["사과", "오렌지", "배"]; alert( fruits.pop() ); // 배열에서 "배"를 제거하고 제거된 요소를 얼럿창에 띄운다. alert( fruits ); // 사과,오렌지`

- `push`

  배열 끝에 요소를 추가한다.`let fruits = ["사과", "오렌지"]; fruits.push("배"); alert( fruits ); // 사과,오렌지,배``fruits.push(...)`를 호출하는 것은 `fruits[fruits.length] = ...`하는 것과 같은 효과를 보인다.

**아래는 배열 앞에 무언가를 해주는 메서드이다.**

- `shift`

  배열 앞 요소를 제거하고, 제거한 요소를 반환한다.`let fruits = ["사과", "오렌지", "배"]; alert( fruits.shift() ); // 배열에서 "사과"를 제거하고 제거된 요소를 얼럿창에 띄웁니다. alert( fruits ); // 오렌지,배`

- `unshift`

  배열 앞에 요소를 추가한다.`let fruits = ["오렌지", "배"]; fruits.unshift('사과'); alert( fruits ); // 사과,오렌지,배`

`push`와 `unshift`는 요소 여러 개를 한 번에 더해줄 수도 있다.

```javascript
let fruits = ["사과"];

fruits.push("오렌지", "배");
fruits.unshift("파인애플", "레몬");

// ["파인애플", "레몬", "사과", "오렌지", "배"]
alert( fruits );
```





#### 배열의 내부 동작 원리

배열은 특별한 종류의 객체이다. 배열 `arr`의 요소를 `arr[0]`처럼 대괄호를 사용해 접근하는 방식은 객체 문법에서 왔다. 다만 배열은 키가 숫자라는 점만 다르다.

숫자형 키를 사용함으로써 배열은 객체 기본 기능 이외에도 순서가 있는 컬렉션을 제어하게 해주는 특별한 메서드를 제공한다. `length`라는 프로퍼티도 제공하지만 어쨌든 배열의 본질은 객체이다.

이렇게 배열은 자바스크립트의 일곱 가지 원시 자료형에 해당하지 않고, 원시 자료형이 아닌 객체형에 속하기 때문에 객체처럼 동작한다.

예시를 하나 살펴보자. 배열은 객체와 마찬가지로 참조를 통해 복사된다.

```javascript
let fruits = ["바나나"]

let arr = fruits; // 참조를 복사함(두 변수가 같은 객체를 참조)

alert( arr === fruits ); // true

arr.push("배"); // 참조를 이용해 배열을 수정한다.

alert( fruits ); // 바나나,배 - 요소가 두 개가 되었다.
```



배열을 배열답게 만들어주는 것은 특수 내부 표현방식이다. 자바스크립트 엔진은 아래쪽 그림에서처럼 배열의 요소를 인접한 메모리 공간에 차례로 저장해 연산 속도를 높인다. 이 방법 이외에도 배열 관련 연산을 더 빠르게 해주는 최적화 기법은 다양하다.

그런데 개발자가 배열을 '순서가 있는 자료의 컬렉션’처럼 다루지 않고 일반 객체처럼 다루면 이런 기법들이 제대로 동작하지 않는다.

```javascript
let fruits = []; // 빈 배열을 하나 만든다.

fruits[99999] = 5; // 배열의 길이보다 훨씬 큰 숫자를 사용해 프로퍼티를 만든다.

fruits.age = 25; // 임의의 이름을 사용해 프로퍼티를 만든다.
```

배열은 객체이므로 예시처럼 원하는 프로퍼티를 추가해도 문제가 발생하지 않는다.

그런데 이렇게 코드를 작성하면 자바스크립트 엔진이 배열을 일반 객체처럼 다루게 되어 배열을 다룰 때만 적용되는 최적화 기법이 동작하지 않아 배열 특유의 이점이 사라진다.

잘못된 방법의 예는 다음과 같다.

- `arr.test = 5` 같이 숫자가 아닌 값을 프로퍼티 키로 사용하는 경우
- `arr[0]`과 `arr[1000]`만 추가하고 그사이에 아무런 요소도 없는 경우
- `arr[1000]`, `arr[999]`같이 요소를 역순으로 채우는 경우

배열은 *순서가 있는 자료*를 저장하는 용도로 만들어진 특수한 자료구조이다. 배열 내장 메서드들은 이런 용도에 맞게 만들어졌다. 자바스크립트 엔진은 이런 특성을 고려하여 배열을 신중하게 조정하고, 처리하므로 배열을 사용할 땐 이런 목적에 맞게 사용해야 한다. 임의의 키를 사용해야 한다면 배열보단 일반 객체 `{}`가 적합한 자료구조일 확률이 높다.





#### 성능 - `push`와 `pop`은 빠르지만 `shift`와 `unshift`는 느립니다.

배열 앞에 무언가를 해주는 메서드가 배열 끝에 무언가를 해주는 메서드보다 느린 이유를 실행 흐름을 살펴보면서 알아보자.

```javascript
fruits.shift(); // 배열 맨 앞의 요소를 빼준다.
```

`shift` 메서드를 호출한 것과 동일한 효과를 보려면 인덱스가 `0`인 요소를 제거하는 것만으론 충분하지 않다. 제거 대상이 아닌 나머지 요소들의 인덱스를 수정해 줘야 하기 때문이다.

`shift` 연산은 아래 3가지 동작을 모두 수행해야 이뤄진다.

1. 인덱스가 `0`인 요소를 제거한다.
2. 모든 요소를 왼쪽으로 이동시킨다. 이때 인덱스 `1`은 `0`, `2`는 `1`로 변한다.
3. `length` 프로퍼티 값을 갱신한다.

그런데 **배열에 요소가 많으면 요소가 이동하는 데 걸리는 시간이 길고 메모리 관련 연산도 많아진다.**

`unshift`를 실행했을 때도 이와 유사한 일이 일어난다. 요소를 배열 앞에 추가하려면 일단 기존 요소들을 오른쪽으로 이동시켜야 하는데, 이때 인덱스도 바꿔줘야 한다.

그렇다면 `push`나 `pop`은 어떨까? 이 둘은 요소 이동을 수반하지 않는다. `pop` 메서드로 요소를 끝에서 제거하려면 마지막 요소를 제거하고 `length` 프로퍼티의 값을 줄여주기만 하면 된다.

`pop` 메서드를 호출하면 다음과 같은 동작이 일어난다.

```javascript
fruits.pop(); // 배열 끝 요소 하나를 제거한다.
```

**`pop` 메서드는 요소를 옮기지 않으므로 각 요소는 기존 인덱스를 그대로 유지한다. 배열 끝에 무언가를 해주는 메서드의 실행 속도가 빠른 이유는 바로 여기에 있다.**

`push` 메서드를 쓸 때도 유사한 동작이 일어나므로 속도가 빠르다.



#### 반복문

`for`문은 배열을 순회할 때 쓰는 가장 오래된 방법입니다. 순회시엔 인덱스를 사용한다.

```javascript
let arr = ["사과", "오렌지", "배"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
```

배열에 적용할 수 있는 또 다른 순회 문법으론 `for..of`가 있다.

```javascript
let fruits = ["사과", "오렌지", "자두"];

// 배열 요소를 대상으로 반복 작업을 수행한다.
for (let fruit of fruits) {
  alert( fruit );
}
```

`for..of`를 사용하면 현재 요소의 인덱스는 얻을 수 없고 값만 얻을 수 있다. 이 정도 기능이면 원하는 것을 충분히 구현할 수 있고 문법도 짧기 때문에 배열의 요소를 대상으로 반복 작업을 할 땐 `for..of`를 사용해 보자.

배열은 객체형에 속하므로 `for..in`을 사용하는 것도 가능하다.

```javascript
let arr = ["사과", "오렌지", "배"];

for (let key in arr) {
  alert( arr[key] ); // 사과, 오렌지, 배
}
```

그런데 `for..in`은 다음과 같은 특징을 지니기 때문에 배열에 `for..in`을 사용하면 문제가 발생하므로 되도록 다른 반복문을 사용하자.

1. `for..in` 반복문은 *모든 프로퍼티*를 대상으로 순회한다. 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함된다.

   브라우저나 기타 호스트 환경에서 쓰이는 객체 중, *배열*과 유사한 형태를 보이는 ‘유사 배열(array-like)’ 객체가 있다. 유사 배열 객체엔 배열처럼 `length` 프로퍼티도 있고 요소마다 인덱스도 붙어 있는데 여기에 더하여 유사 배열 객체엔 배열과는 달리 키가 숫자형이 아닌 프로퍼티와 메서드가 있을 수 있다. 유사 배열 객체와 `for..in`을 함께 사용하면 이 모든 것을 대상으로 순회가 이뤄진다. 따라서 ‘필요 없는’ 프로퍼티들이 문제를 일으킬 가능성이 생긴다.

2. `for..in` 반복문은 배열이 아니라 객체와 함께 사용할 때 최적화되어 있어서 배열에 사용하면 객체에 사용하는 것 대비 10~100배 정도 느리다. `for..in` 반복문의 속도가 대체로 빠른 편이기 때문에 병목 지점에서만 문제가 되긴 하지만 `for..in` 반복문을 사용할 땐 이런 차이를 알고 적절한 곳에 사용하시길 바란다.

그러니 배열엔 되도록 `for..in`를 쓰지 말자.



#### length’ 프로퍼티

배열에 무언가 조작을 가하면 `length` 프로퍼티가 자동으로 갱신된다. `length` 프로퍼티는 배열 내 요소의 개수가 아니라 가장 큰 인덱스에 1을 더한 값이다.

따라서 배열에 요소가 하나 있고, 이 요소의 인덱스가 아주 큰 정수라면 배열의 `length` 프로퍼티도 아주 커진다.

```javascript
let fruits = [];
fruits[123] = "사과";

alert( fruits.length ); // 124
```

배열을 이렇게 사용하지 않도록 하자.

`length` 프로퍼티의 또 다른 독특한 특징 중 하나는 쓰기가 가능하다는 점이다.

`length`의 값을 수동으로 증가시키면 아무 일도 일어나지 않는다. 그런데 값을 감소시키면 배열이 잘립니다. 짧아진 배열은 다시 되돌릴 수 없다. 

```javascript
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // 요소 2개만 남기고 잘라보자.
alert( arr ); // [1, 2]

arr.length = 5; // 본래 길이로 되돌려 보자.
alert( arr[3] ); // undefined: 삭제된 기존 요소들이 복구되지 않는다.
```

이런 특징을 이용하면 `arr.length = 0;`을 사용해 아주 간단하게 배열을 비울 수 있습니다.





#### new Array()

위에서도 잠시 언급했지만 `new Array()` 문법을 사용해도 배열을 만들 수 있다.

```javascript
let arr = new Array("사과", "배", "기타");
```

대괄호 `[]`를 사용하면 더 짧은 문법으로 배열을 만들 수 있기 때문에 `new Array()`는 잘 사용되지 않는 편이다. `new Array()`엔 다루기 까다로운 기능도 있어서 더욱더 그렇다.

숫자형 인수 하나를 넣어서 `new Array`를 호출하면 배열이 만들어지는데, 이 배열엔 *요소가 없는 반면 길이는 인수와 같아*진다.

예시를 통해 `new Array()`의 이런 특징이 어떻게 실수를 유발할 수 있는지 알아보자.

```javascript
let arr = new Array(2); // 이렇게 하면 배열 [2]가 만들어질까?

alert( arr[0] ); // undefined가 출력된다. 요소가 하나도 없는 배열이 만들어졌다.

alert( arr.length ); // 길이는 2이다.
```

위 예시에서 확인해 본 것처럼 `new Array(number)`를 이용해 만든 배열의 요소는 모두 `undefined` 이다.

이런 뜻밖의 상황을 마주치지 않기 위해 `new Array`의 기능을 잘 알지 않는 한 대부분의 개발자가 대괄호를 써서 배열을 만들어야 한다.





#### 다차원 배열

배열 역시 배열의 요소가 될 수 있다. 이런 배열을 가리켜 다차원 배열(multidimensional array)이라 부른다. 다차원 배열은 행렬을 저장하는 용도로 쓰인다.

```javascript
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5, 중심에 있는 요소
```



#### toString

배열엔 `toString` 메서드가 구현되어 있어 이를 호출하면 요소를 쉼표로 구분한 문자열이 반환된다.

```javascript
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
```



아래 예시를 실행해 보면

```javascript
alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
```

배열엔 `Symbol.toPrimitive`나 `valueOf` 메서드가 없다. 따라서 위 예시에선 문자열로의 형 변환이 일어나 `[]`는 빈 문자열, `[1]`은 문자열 `"1"`, `[1,2]`는 문자열 `"1,2"`로 변환된다.

이항 덧셈 연산자 `"+"`는 피연산자 중 하나가 문자열인 경우 나머지 피연산자도 문자열로 변환한다. 따라서 위 예시는 아래 예시와 동일하게 동작한다.

```javascript
alert( "" + 1 ); // "1"
alert( "1" + 1 ); // "11"
alert( "1,2" + 1 ); // "1,21"
```







> #### 요약
>
> 배열은 특수한 형태의 객체로, 순서가 있는 자료를 저장하고 관리하는 용도에 최적화된 자료구조이다.
>
> - 선언 방법:
>
>   ```javascript
>   // 대괄호 (가장 많이 쓰이는 방법임)
>   let arr = [item1, item2...];
>   
>   // new Array (잘 쓰이지 않음)
>   let arr = new Array(item1, item2...);
>   ```
>
>   `new Array(number)`을 호출하면 길이가 `number`인 배열이 만들어지는데, 이 때 요소는 비어있다.
>
> - `length` 프로퍼티는 배열의 길이를 나타내준다. 정확히는 숫자형 인덱스 중 가장 큰 값에 1을 더한 값이다. 배열 메서드는 `length` 프로퍼티를 자동으로 조정해준다.
>
> - `length` 값을 수동으로 줄이면 배열 끝이 잘린다.
>
> 다음 연산을 사용하면 배열을 데큐처럼 사용할 수 있다.
>
> - `push(...items)` – `items`를 배열 끝에 더해준다.
> - `pop()` – 배열 끝 요소를 제거하고, 제거한 요소를 반환한다.
> - `shift()` – 배열 처음 요소를 제거하고, 제거한 요소를 반환한다.
> - `unshift(...items)` – `items`를 배열 처음에 더해즌다.
>
> 아래 방법을 사용하면 모든 요소를 대상으로 반복 작업을 할 수 있다.
>
> - `for (let i=0; i<arr.length; i++)` – 가장 빠른 방법이고 오래된 브라우저와도 호환된다.
> - `for (let item of arr)` – 배열 요소에만 사용되는 모던한 문법이다.
> - `for (let i in arr)` – 배열엔 절대 사용하지 말자.











## 5.5 배열과 메서드



#### 요소 추가·제거 메서드

배열의 맨 앞이나 끝에 요소(item)를 추가하거나 제거하는 메서드는 아래와 같다.

- `arr.push(...items)` – 맨 끝에 요소 추가

- `arr.pop()` – 맨 끝 요소 제거

- `arr.shift()` – 맨 앞 요소 제거

- `arr.unshift(...items)` – 맨 앞에 요소 추가

  

이 외에 요소 추가와 제거에 관련된 메서드를 알아보자.

### 

#### splice

배열에서 요소를 하나만 지우고 싶다면 어떻게 해야 할까?

배열 역시 객체형에 속하므로 프로퍼티를 지울 때 쓰는 연산자 `delete`를 사용해 볼 수 있다.

```javascript
let arr = ["I", "go", "home"];

delete arr[1]; // "go"를 삭제한다.

alert( arr[1] ); // undefined

// delete를 써서 요소를 지우고 난 후 배열 --> arr = ["I",  , "home"];
alert( arr.length ); // 3
```

원하는 대로 요소를 지웠지만 배열의 요소는 여전히 세 개이다. `arr.length == 3`을 통해 이를 확인할 수 있다.

이는 자연스러운 결과인데  `delete obj.key`는 `key`를 이용해 해당 키에 상응하는 값을 지우기 때문이다. `delete` 메서드는 제 역할을 다 한 것이다. 그런데 우리는 삭제된 요소가 만든 빈 공간을 나머지 요소들이 자동으로 채울 것이라 기대하며 이 메서드를 썼다. 또 배열의 길이가 짧아 지기 위한 이런 기대를 충족하려면 특별한 메서드를 사용해야 한다.

[arr.splice(start)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)는 요소를 자유자재로 다룰 수 있게 해준다. 이 메서드를 사용하면 요소 추가, 삭제, 교체가 모두 가능하다.



```javascript
arr.splice(index[, deleteCount, elem1, ..., elemN])
```

첫 번째 매개변수는 조작을 가할 첫 번째 요소를 가리키는 `인덱스(index)` 이다. 두 번째 매개변수는 `deleteCount`로, 제거하고자 하는 요소의 개수를 나타낸다. `elem1, ..., elemN`은 배열에 추가할 요소를 나타낸다.



먼저 요소 삭제에 관한 예시부터 살펴보자.

```javascript
let arr = ["I", "study", "JavaScript"];

arr.splice(1, 1); // 인덱스 1부터 요소 한 개를 제거

alert( arr ); // ["I", "JavaScript"]
```

쉽죠? 인덱스 `1`이 가리키는 요소부터 시작해 요소 한 개(`1`)를 지웠다.

다음 예시에선 요소 세 개(3)를 지우고, 그 자리를 다른 요소 두 개로 교체해 보도록 하자.

```javascript
let arr = ["I", "study", "JavaScript", "right", "now"];

// 처음(0) 세 개(3)의 요소를 지우고, 이 자리를 다른 요소로 대체한다.
arr.splice(0, 3, "Let's", "dance");

alert( arr ) // now ["Let's", "dance", "right", "now"]
```

`splice`는 삭제된 요소로 구성된 배열을 반환한다. 아래 예시를 통해 확인해 보자.

```javascript
let arr = ["I", "study", "JavaScript", "right", "now"];

// 처음 두 개의 요소를 삭제함
let removed = arr.splice(0, 2);

alert( removed ); // "I", "study" <-- 삭제된 요소로 구성된 배열
```

`splice` 메서드의 `deleteCount`를 `0`으로 설정하면 요소를 제거하지 않으면서 새로운 요소를 추가할 수 있다.

```javascript
let arr = ["I", "study", "JavaScript"];

// 인덱스 2부터
// 0개의 요소를 삭제합니다.
// 그 후, "complex"와 "language"를 추가한다.
arr.splice(2, 0, "complex", "language");

alert( arr ); // "I", "study", "complex", "language", "JavaScript"
```

**음수 인덱스도 사용할 수 있다.**

slice 메서드 뿐만 아니라 배열 관련 메서드엔 음수 인덱스를 사용할 수 있다. 이때 마이너스 부호 앞의 숫자는 배열 끝에서부터 센 요소 위치를 나타낸다. 

```javascript
let arr = [1, 2, 5];

// 인덱스 -1부터 (배열 끝에서부터 첫 번째 요소)
// 0개의 요소를 삭제하고
// 3과 4를 추가합니다.
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
```

### 

#### slice

[arr.slice](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)는 `arr.splice`와 유사해 보이지만 훨씬 간단하다.



```javascript
arr.slice([start], [end])
```

이 메서드는 `"start"` 인덱스부터 (`"end"`를 제외한) `"end"`인덱스까지의 요소를 복사한 새로운 배열을 반환한다. `start`와 `end`는 둘 다 음수일 수 있는데 이땐, 배열 끝에서부터의 요소 개수를 의미한다.



`arr.slice`는 문자열 메서드인 `str.slice`와 유사하게 동작하는데 `arr.slice`는 서브 문자열(substring) 대신 서브 배열(subarray)을 반환한다는 점이 다르다.

```javascript
let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (인덱스가 1인 요소부터 인덱스가 3인 요소까지를 복사(인덱스가 3인 요소는 제외))

alert( arr.slice(-2) ); // s,t (인덱스가 -2인 요소부터 제일 끝 요소까지를 복사)
```

`arr.slice()`는 인수를 하나도 넘기지 않고 호출하여 `arr`의 복사본을 만들 수 있다. 이런 방식은 기존의 배열을 건드리지 않으면서 배열을 조작해 새로운 배열을 만들고자 할 때 자주 사용된다.

### 

#### concat

[arr.concat](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)은 기존 배열의 요소를 사용해 새로운 배열을 만들거나 기존 배열에 요소를 추가하고자 할 때 사용할 수 있다.

문법은 다음과 같다.

```javascript
arr.concat(arg1, arg2...)
```

인수엔 배열이나 값이 올 수 있는데, 인수 개수엔 제한이 없다.

메서드를 호출하면 `arr`에 속한 모든 요소와 `arg1`, `arg2` 등에 속한 모든 요소를 한데 모은 새로운 배열이 반환된다.

인수 `argN`가 배열일 경우 배열의 모든 요소가 복사된다. 그렇지 않은경우(단순 값인 경우)는 인수가 그대로 복사된다.



```javascript
let arr = [1, 2];

// arr의 요소 모두와 [3,4]의 요소 모두를 한데 모은 새로운 배열이 만들어진다.
alert( arr.concat([3, 4]) ); // 1,2,3,4

// arr의 요소 모두와 [3,4]의 요소 모두, [5,6]의 요소 모두를 모은 새로운 배열이 만들어진다.
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// arr의 요소 모두와 [3,4]의 요소 모두, 5와 6을 한데 모은 새로운 배열이 만들어진다.
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
```

`concat` 메서드는 제공받은 배열의 요소를 복사해 활용한다. 객체가 인자로 넘어오면 (배열처럼 보이는 유사 배열 객체이더라도) 객체는 분해되지 않고 통으로 복사되어 더해진다.

```javascript
let arr = [1, 2];

let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
```

그런데 인자로 받은 유사 배열 객체에 특수한 프로퍼티 `Symbol.isConcatSpreadable`이 있으면 `concat`은 이 객체를 배열처럼 취급한다. 따라서 객체 전체가 아닌 객체 프로퍼티의 값이 더해진다.

```javascript
let arr = [1, 2];

let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
```



#### forEach로 반복작업 하기

[arr.forEach](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)는 주어진 함수를 배열 요소 각각에 대해 실행할 수 있게 해준다.



```javascript
arr.forEach(function(item, index, array) {
  // 요소에 무언가를 할 수 있다.
});
```

아래는 요소 모두를 얼럿창을 통해 출력해주는 코드이다.

```javascript
// for each element call alert
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
```

아래는 인덱스 정보까지 더해서 출력해주는 좀 더 정교한 코드이다.

```javascript
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
```

참고로, 인수로 넘겨준 함수의 반환값은 무시된다.





#### 배열 탐색하기

배열 내에서 무언가를 찾고 싶을 때 쓰는 메서드에 대해 알아보자.

### 

#### indexOf, lastIndexOf와 includes

[arr.indexOf](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)와 [arr.lastIndexOf](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf), [arr.includes](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)는 같은 이름을 가진 문자열 메서드와 문법이 동일하다. 물론 하는 일도 같습니다. 연산 대상이 문자열이 아닌 배열의 요소라는 점만 다르다.

- `arr.indexOf(item, from)`는 인덱스 `from`부터 시작해 `item(요소)`을 찾는다. 요소를 발견하면 해당 요소의 인덱스를 반환하고, 발견하지 못했으면 `-1`을 반환한다.
- `arr.lastIndexOf(item, from)`는 위 메서드와 동일한 기능을 하는데, 검색을 끝에서부터 시작한다는 점만 다르다.
- `arr.includes(item, from)`는 인덱스 `from`부터 시작해 `item`이 있는지를 검색하는데, 해당하는 요소를 발견하면 `true`를 반환한다.

예시:

```javascript
let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
```

위 메서드들은 요소를 찾을 때 완전 항등 연산자 `===` 을 사용한다는 점에 유의하시기 바란다. 보시는 바와 같이 `false`를 검색하면 정확히 `false`만을 검색하지, 0을 검색하진 않는다.

요소의 위치를 정확히 알고 싶은게 아니고 요소가 배열 내 존재하는지 여부만 확인하고 싶다면 `arr.includes`를 사용하는 게 좋다.

`includes`는 `NaN`도 제대로 처리한다는 점에서 `indexOf/lastIndexOf`와 약간의 차이가 있다.

```javascript
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (완전 항등 비교 === 는 NaN엔 동작하지 않으므로 0이 출력되지 않는다.)
alert( arr.includes(NaN) );// true (NaN의 여부를 확인하였다.)
```

### 



#### find와 findIndex

객체로 이루어진 배열이 있다고 가정해 보자. 특정 조건에 부합하는 객체를 배열 내에서 어떻게 찾을 수 있을까?

이럴 때 [arr.find(fn)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/find)을 사용할 수 있다.



```javascript
let result = arr.find(function(item, index, array) {
  // true가 반환되면 반복이 멈추고 해당 요소를 반환한다.
  // 조건에 해당하는 요소가 없으면 undefined를 반환한다.
});
```

요소 전체를 대상으로 함수가 순차적으로 호출된다.

- `item` – 함수를 호출할 요소
- `index` – 요소의 인덱스
- `array` – 배열 자기 자신

함수가 참을 반환하면 탐색은 중단되고 해당 `요소`가 반환된다. 원하는 요소를 찾지 못했으면 `undefined`가 반환된다.

`id`와 `name` 프로퍼티를 가진 사용자 객체로 구성된 배열을 예로 들어보자. 배열 내에서 `id == 1` 조건을 충족하는 사용자 객체를 찾아보자.

```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
```

실무에서 객체로 구성된 배열을 다뤄야 할 일이 잦기 때문에 `find` 메서드 활용법을 알아두면 좋다.

그런데 위 예시에서 `find` 안의 함수가 인자를 하나만 가지고 있다는 점에 주목해보자(`item => item.id == 1`). 이런 패턴이 가장 많이 사용되는 편인데 다른 인자들(`index`, `array`)은 잘 사용되지 않는다.

[arr.findIndex](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)는 `find`와 동일한 일을 하나, 조건에 맞는 요소를 반환하는 대신 해당 요소의 인덱스를 반환한다는 점이 다르다. 조건에 맞는 요소가 없으면 `-1`이 반환된다.

### 

#### filter

`find` 메서드는 함수의 반환 값을 `true`로 만드는 단 하나의 요소를 찾는다.

조건을 충족하는 요소가 여러 개라면 [arr.filter(fn)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)를 사용하면 된다.

`filter`는 `find`와 문법이 유사하지만, 조건에 맞는 요소 전체를 담은 배열을 반환한다는 점에서 차이가 있다.

```javascript
let results = arr.filter(function(item, index, array) {
  // 조건을 충족하는 요소는 results에 순차적으로 더해진다.
  // 조건을 충족하는 요소가 하나도 없으면 빈 배열이 반환된다.
});
```



```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// 앞쪽 사용자 두 명을 반환한다.
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```





#### 배열을 변형하는 메서드

배열을 변형시키거나 요소를 재 정렬해주는 메서드에 대해 알아보자.

### 

#### map

[arr.map](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map)은 유용성과 사용 빈도가 아주 높은 메서드 중 하나이다.

`map`은 배열 요소 전체를 대상으로 함수를 호출하고, 함수 호출 결과를 배열로 반환해준다.



```javascript
let result = arr.map(function(item, index, array) {
  // 요소 대신 새로운 값을 반환한다.
});
```

아래 예시에선 각 요소(문자열)의 길이를 출력해준다.

```javascript
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
```

### 



#### sort(fn)

[arr.sort()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)는 배열의 요소를 정렬해준다. 배열 *자체*가 변경된다.

메서드를 호출하면 재정렬 된 배열이 반환되는데, 이미 `arr` 자체가 수정되었기 때문에 반환 값은 잘 사용되지 않는 편이다.

```javascript
let arr = [ 1, 2, 15 ];

// arr 내부가 재 정렬된다.
arr.sort();

alert( arr );  // 1, 15, 2
```



뭔가 이상하다. 재정렬 후 배열 요소가 `1, 15, 2`가 되었기 때문이다. 기대하던 결과(`1, 2, 15`)와는 다른데,  왜 이런 결과가 나왔을까?

**요소는 문자열로 취급되어 재 정렬되기 때문이다.**

모든 요소는 문자형으로 변환된 이후에 재 정렬된다. 앞서 배웠듯이 문자열 비교는 사전편집 순으로 진행되기 때문에 2는 15보다 큰 값으로 취급된다(`"2" > "15"`).

기본 정렬 기준 대신 새로운 정렬 기준을 만들려면 `arr.sort()`에 새로운 함수를 넘겨줘야 한다.

인수로 넘겨주는 함수는 반드시 값 두 개를 비교해야 하고 반환 값도 있어야 한다.

```javascript
function compare(a, b) {
  if (a > b) return 1; // 첫 번째 값이 두 번째 값보다 큰 경우
  if (a == b) return 0; // 두 값이 같은 경우
  if (a < b) return -1; //  첫 번째 값이 두 번째 값보다 작은 경우
}
```

이제 배열 요소를 숫자 오름차순 기준으로 정렬해보자.

```javascript
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
```

이제 기대했던 대로 요소가 정렬되었다.

여기서 잠시 멈춰 위 예시에서 어떤 일이 일어났는지 생각해 보자. 사실 `arr`엔 숫자, 문자열, 객체 등이 들어갈 수 있다. 알 수 없는 *무언가*로 구성된 집합이 되는 것이다. 이제 이 비 동질적인 집합을 정렬해야 한다고 가정해보면, 무언가를 정렬하려면 기준이 필요하다. 이때 *정렬 기준을 정의해주는 함수(ordering function, 정렬 함수)* 가 필요하고, `sort`에 정렬 함수를 인수로 넘겨주지 않으면 이 메서드는 사전편집 순으로 요소를 정렬한다.

`arr.sort(fn)`는 포괄적인 정렬 알고리즘을 이용해 구현되어있다. 대개 최적화된 [퀵 소트(quicksort)](https://en.wikipedia.org/wiki/Quicksort)를 사용하는데, `arr.sort(fn)`는 주어진 함수를 사용해 정렬 기준을 만들고 이 기준에 따라 요소들을 재배열하므로 개발자는 내부 정렬 동작 원리를 알 필요가 없다. 우리가 해야 할 일은 정렬 함수 `fn`을 만들고 이를 인수로 넘겨주는 것뿐이다.

정렬 과정에서 어떤 요소끼리 비교가 일어났는지 확인하고 싶다면 아래 코드를 활용하시면 된다.

```javascript
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
  return a - b;
});
```

정렬 중에 한 요소가 특정 요소와 여러 번 비교되는 일이 생기곤 하는데 비교 횟수를 최소화 하려다 보면 이런 일이 발생할 수 있다.

**정렬 함수는 어떤 숫자든 반환할 수 있다.**

정렬 함수의 반환 값엔 제약이 없다. 양수를 반환하는 경우 첫 번째 인수가 두 번째 인수보다 '크다’를 나타내고, 음수를 반환하는 경우 첫 번째 인수가 두 번째 인수보다 '작다’를 나타내기만 하면 된다.

이 점을 이용하면 정렬 함수를 더 간결하게 만들 수 있다.

```javascript
let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
```

**화살표 함수를 사용하자.**

[화살표 함수](https://ko.javascript.info/arrow-functions-basics)를 사용하면 정렬 함수를 더 깔끔하게 만들 수 있다.

```javascript
arr.sort( (a, b) => a - b );
```

화살표 함수를 활용한 코드와 함수 선언문을 사용한 코드는 동일하게 작동한다.

**문자열엔 `localeCompare`를 사용하자.**

[strings](https://ko.javascript.info/string#correct-comparisons)에서 배운 비교 알고리즘은 유니코드를 기준으로 글자를 비교한다.

`Ö`같은 문자가 있는 언어에도 대응하려면 `str.localeCompare` 메서드를 사용해 문자열을 비교하는 게 좋다.

독일어로 나타낸 국가가 요소인 배열을 정렬해보자.

```javascript
let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (제대로 정렬이 되지 않았다.)

alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (제대로 정렬되었다!)
```

### 

#### reverse

[arr.reverse](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)는 `arr`의 요소를 역순으로 정렬시켜주는 메서드이다.

```javascript
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
```

반환 값은 재 정렬된 배열이다.

### 

#### split과 join

메시지 전송 애플리케이션을 만들고 있다고 가정해 보자. 수신자가 여러 명일 경우, 발신자는 쉼표로 각 수신자를 구분할 것이다. `John, Pete, Mary`같이 말이다. 개발자는 긴 문자열 형태의 수신자 리스트를 배열 형태로 전환해 처리하고 싶을 거다. 입력받은 문자열을 어떻게 배열로 바꿀 수 있을까?

[str.split(delim)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/split)을 이용하면 우리가 원하는 것을 정확히 할 수 있다. 이 메서드는 구분자(delimiter) `delim`을 기준으로 문자열을 쪼개준다.

아래 예시에선 쉼표와 공백을 합친 문자열이 구분자로 사용되고 있다.

```javascript
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert( `${name}에게 보내는 메시지` ); // Bilbo에게 보내는 메시지
}
```

`split` 메서드는 두 번째 인수로 숫자를 받을 수 있다. 이 숫자는 배열의 길이를 제한해주므로 길이를 넘어서는 요소를 무시할 수 있다. 실무에서 자주 사용하는 기능은 아니다.

```javascript
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
```



**문자열을 글자 단위로 분리하기**

`split(s)`의 `s`를 빈 문자열로 지정하면 문자열을 글자 단위로 분리할 수 있다.

```javascript
let str = "test";

alert( str.split('') ); // t,e,s,t
```

[arr.join(glue)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/join)은 `split`과 반대 역할을 하는 메서드이다. 인수 `glue`를 접착제처럼 사용해 배열 요소를 모두 합친 후 하나의 문자열을 만들어준다.



```javascript
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // 배열 요소 모두를 ;를 사용해 하나의 문자열로 합친다.

alert( str ); // Bilbo;Gandalf;Nazgul
```

### 



#### reduce와 reduceRight

`forEach`, `for`, `for..of`를 사용하면 배열 내 요소를 대상으로 반복 작업을 할 수 있다.

각 요소를 돌면서 반복 작업을 수행하고, 작업 결과물을 새로운 배열 형태로 얻으려면 `map`을 사용하면 된다.

[arr.reduce](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)와 [arr.reduceRight](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight)도 이런 메서드들과 유사한 작업을 해준다. 그런데 사용법이 조금 복잡하다. `reduce`와 `reduceRight`는 배열을 기반으로 값 하나를 도출할 때 사용된다.

```javascript
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```

인수로 넘겨주는 함수는 배열의 모든 요소를 대상으로 차례차례 적용되는데, 적용 결과는 다음 함수 호출 시 사용된다.

함수의 인수는 다음과 같다.

- `accumulator` – 이전 함수 호출의 결과. `initial`은 함수 최초 호출 시 사용되는 초깃값을 나타냄(옵션)
- `item` – 현재 배열 요소
- `index` – 요소의 위치
- `array` – 배열

이전 함수 호출 결과는 다음 함수를 호출할 때 첫 번째 인수(`previousValue`)로 사용됩니다.

첫 번째 인수는 앞서 호출했던 함수들의 결과가 누적되어 저장되는 '누산기(accumulator)'라고 생각하면 됩니다. 마지막 함수까지 호출되면 이 값은 `reduce`의 반환 값이 됩니다.

복잡해 보이긴 하지만 예제를 통해 메서드를 이해해 봅시다.

`reduce`를 이용해 코드 한 줄로 배열의 모든 요소를 더한 값을 구해보겠습니다.

```javascript
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
```

`reduce`에 전달한 함수는 오직 인수 두 개만 받고 있다. 대개 이렇게 인수를 두 개만 받는다.

이제 어떤 과정을 거쳐 위와 같은 결과가 나왔는지 자세히 살펴보자.

1. 함수 최초 호출 시, `reduce`의 마지막 인수인 `0(초깃값)`이 `sum`에 할당된다. `current`엔 배열의 첫 번째 요소인 `1`이 할당된다. 따라서 함수의 결과는 `1`이 된다.
2. 두 번째 호출 시, `sum = 1` 이고 여기에 배열의 두 번째 요소(`2`)가 더해지므로 결과는 `3`이 된다.
3. 세 번째 호출 시, `sum = 3` 이고 여기에 배열의 다음 요소가 더해지며, 이런 과정이 계속 이어진다.

계산 흐름:

![스크린샷 2021-05-03 오후 4 17 20](https://user-images.githubusercontent.com/79819941/116851019-a0212f80-ac2c-11eb-8d4c-d2fd93c5ecd7.png) 

표를 이용해 설명하면 아래와 같다. 함수가 호출될 때마다 넘겨지는 인수와 연산 결과는 각 열에서 확인할 수 있다.

|               | `sum` | `current` | result |
| :------------ | :---- | :-------- | :----- |
| 첫 번째 호출  | `0`   | `1`       | `1`    |
| 두 번째 호출  | `1`   | `2`       | `3`    |
| 세 번째 호출  | `3`   | `3`       | `6`    |
| 네 번째 호출  | `6`   | `4`       | `10`   |
| 다섯번째 호출 | `10`  | `5`       | `15`   |



한편, 아래와 같이 초깃값을 생략하는 것도 가능하다.

```javascript
let arr = [1, 2, 3, 4, 5];

// reduce에서 초깃값을 제거함(0이 없음)
let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
```

초깃값을 없애도 결과는 동일하다. 초깃값이 없으면 `reduce`는 배열의 첫 번째 요소를 초깃값으로 사용하고 두 번째 요소부터 함수를 호출하기 때문이다.

위 표에서 첫 번째 호출에 관련된 줄만 없애면 초깃값 없이 계산한 위 예제의 계산 흐름이 된다.

하지만 이렇게 초깃값 없이 `reduce`를 사용할 땐 극도의 주의를 기울여야 한다. 배열이 비어있는 상태면 `reduce` 호출 시 에러가 발생하기 때문이다.



```javascript
let arr = [];

// TypeError: Reduce of empty array with no initial value
// 초깃값을 설정해 주었다면 초깃값이 반환되었을 것이다.
arr.reduce((sum, current) => sum + current);
```

이런 예외상황 때문에 항상 초깃값을 명시해 줄 것을 권장한다.

[arr.reduceRight](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight)는 `reduce`와 동일한 기능을 하지만 배열의 오른쪽부터 연산을 수행한다는 점이 다른 메서드이다.



#### Array.isArray로 배열 여부 알아내기

자바스크립트에서 배열은 독립된 자료형으로 취급되지 않고 객체형에 속한다.

따라서 `typeof`로는 일반 객체와 배열을 구분할 수가 없다.

```javascript
alert(typeof {}); // object
alert(typeof []); // object
```

그런데 배열은 자주 사용되는 자료구조이기 때문에 배열인지 아닌지를 감별해내는 특별한 메서드가 있다면 아주 유용할 것이다. [Array.isArray(value)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)는 이럴 때 사용할 수 있는 유용한 메서드이다. `value`가 배열이라면 `true`를, 배열이 아니라면 `false`를 반환해준다.

```javascript
alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
```





#### 배열 메서드와 ‘thisArg’

함수를 호출하는 대부분의 배열 메서드(`find`, `filter`, `map` 등. `sort`는 제외)는 `thisArg`라는 매개변수를 옵션으로 받을 수 있다.

`thisArg`는 아래와 같이 활용할 수 있다.

```javascript
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg는 선택적으로 사용할 수 있는 마지막 인수이다.
```

`thisArg`는 `func`의 `this`가 된다.

아래 예시에서 객체 `army`의 메서드를 `filter`의 인자로 넘겨주고 있는데, 이때 `thisArg`는 `canJoin`의 컨텍스트 정보를 넘겨준다.

```javascript
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// army.canJoin 호출 시 참을 반환해주는 user를 찾음
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```

`thisArgs`에 `army`를 지정하지 않고 단순히 `users.filter(army.canJoin)`를 사용했다면 `army.canJoin`은 단독 함수처럼 취급되고, 함수 본문 내 `this`는 `undefined`가 되어 에러가 발생했을 것이다.

`users.filter(user => army.canJoin(user))`를 사용하면 `users.filter(army.canJoin, army)`를 대체할 수 있긴 한데 `thisArg`를 사용하는 방식이 좀 더 이해하기 쉬우므로 더 자주 사용된다.





> #### 요약
>
> - 요소를 더하거나 지우기
>   - `push(...items)` – 맨 끝에 요소 추가하기
>   - `pop()` – 맨 끝 요소 추출하기
>   - `shift()` – 첫 요소 추출하기
>   - `unshift(...items)` – 맨 앞에 요소 추가하기
>   - `splice(pos, deleteCount, ...items)` – `pos`부터 `deleteCount`개의 요소를 지우고, `items` 추가하기
>   - `slice(start, end)` – `start`부터 `end` 바로 앞까지의 요소를 복사해 새로운 배열을 만듦
>   - `concat(...items)` – 배열의 모든 요소를 복사하고 `items`를 추가해 새로운 배열을 만든 후 이를 반환함. `items`가 배열이면 이 배열의 인수를 기존 배열에 더해줌
> - 원하는 요소 찾기
>   - `indexOf/lastIndexOf(item, pos)` – `pos`부터 원하는 `item`을 찾음. 찾게 되면 해당 요소의 인덱스를, 아니면 `-1`을 반환함
>   - `includes(value)` – 배열에 `value`가 있으면 `true`를, 그렇지 않으면 `false`를 반환함
>   - `find/filter(func)` – `func`의 반환 값을 `true`로 만드는 첫 번째/전체 요소를 반환함
>   - `findIndex`는 `find`와 유사함. 다만 요소 대신 인덱스를 반환함
> - 배열 전체 순회하기
>   - `forEach(func)` – 모든 요소에 `func`을 호출함. 결과는 반환되지 않음
> - 배열 변형하기
>   - `map(func)` – 모든 요소에 `func`을 호출하고, 반환된 결과를 가지고 새로운 배열을 만듦
>   - `sort(func)` – 배열을 정렬하고 정렬된 배열을 반환함
>   - `reverse()` – 배열을 뒤집어 반환함
>   - `split/join` – 문자열을 배열로, 배열을 문자열로 변환함
>   - `reduce(func, initial)` – 요소를 차례로 돌면서 `func`을 호출함. 반환값은 다음 함수 호출에 전달함. 최종적으로 하나의 값이 도출됨
> - 기타
>   - `Array.isArray(arr)` – `arr`이 배열인지 여부를 판단함
>
> `sort`, `reverse`, `splice`는 기존 배열을 변형시킨다는 점에 주의하자.
>
> 지금까지 배운 메서드만으로 배열과 관련된 작업 99%를 해결할 수 있다. 아래 메서드는 그냥 참고만 하자.
>
> - [arr.some(fn)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/some)과 [arr.every(fn)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/every)는 배열을 확인한다.
>
>   두 메서드는 `map`과 유사하게 모든 요소를 대상으로 함수를 호출한다. `some`은 함수의 반환 값을 `true`로 만드는 요소가 하나라도 있는지 여부를 확인하고 `every`는 모든 요소가 함수의 반환 값을 `true`로 만드는지 여부를 확인한다. 두 메서드 모두 조건을 충족하면 `true`를, 그렇지 않으면 `false`를 반환한다.
>
> - [arr.fill(value, start, end)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)은 `start`부터 `end`까지 `value`를 채워 넣는다.
>
> - [arr.copyWithin(target, start, end)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)은 `start`부터 `end`까지 요소를 복사하고, 복사한 요소를 `target`에 붙여넣습니다. 기존 요소가 있다면 덮어쓴다.
>
> 배열에 관한 모든 메서드는 [manual](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array)에서 찾아볼 수 있다.









## 5.6 iterable 객체

*반복 가능한(iterable, 이터러블)* 객체는 배열을 일반화한 객체인데, 이터러블 이라는 개념을 사용하면 어떤 객체에든 `for..of` 반복문을 적용할 수 있다. 배열은 대표적인 이터러블이다. 배열 외에도 다수의 내장 객체가 반복 가능하다. 그리고 문자열 역시 이터러블의 예이다.

배열이 아닌 객체가 있는데, 이 객체가 어떤 것들의 컬렉션(목록, 집합 등)을 나타내고 있는 경우, `for..of` 문법을 적용할 수만 있다면 컬렉션을 순회하는데 유용할 것이다. 



#### Symbol.iterator

직접 이터러블 객체를 만들어 이터러블이라는 개념을 이해해 보도록 하자.

`for..of`를 적용하기에 적합해 보이는 배열이 아닌 객체를 만들어보았는데, 예시의 객체 `range`는 숫자 간격을 나타내고 있다.

```javascript
let range = {
  from: 1,
  to: 5
};

// 아래와 같이 for..of가 동작할 수 있도록 하는 게 목표이다.
// for(let num of range) ... num=1,2,3,4,5
```

`range`를 이터러블로 만들려면(`for..of`가 동작하도록 하려면) 객체에 `Symbol.iterator`(특수 내장 심볼)라는 메서드를 추가해 아래와 같은 일이 벌어지도록 해야 한다.

1. `for..of`가 시작되자마자 `for..of`는 `Symbol.iterator`를 호출한다(`Symbol.iterator`가 없으면 에러가 발생한다). `Symbol.iterator`는 반드시 *이터레이터(iterator, 메서드 `next`가 있는 객체)* 를 반환해야 한다.

2. 이후 `for..of`는 *반환된 객체(이터레이터)만*을 대상으로 동작한다.

3. `for..of`에 다음 값이 필요하면, `for..of`는 이터레이터의 `next()`메서드를 호출한다.

4. `next()`의 반환 값은 `{done: Boolean, value: any}`와 같은 형태이어야 한다. `done=true`는 반복이 종료되었음을 의미한다. `done=false`일땐 `value`에 다음 값이 저장된다.

   

`range`를 반복 가능한 객체로 만들어주는 코드는 다음과 같다.

```javascript
let range = {
  from: 1,
  to: 5
};

// 1. for..of 최초 호출 시, Symbol.iterator가 호출된다.
range[Symbol.iterator] = function() {

  // Symbol.iterator는 이터레이터 객체를 반환한다.
  // 2. 이후 for..of는 반환된 이터레이터 객체만을 대상으로 동작하는데, 이때 다음 값도 정해진다.
  return {
    current: this.from,
    last: this.to,

    // 3. for..of 반복문에 의해 반복마다 next()가 호출된다.
    next() {
      // 4. next()는 값을 객체 {done:.., value :...}형태로 반환해야 한다.
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// 이제 의도한 대로 동작한다!
for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
```

이터러블 객체의 핵심은 '관심사의 분리(Separation of concern, SoC)'에 있다.

- `range`엔 메서드 `next()`가 없다.
- 대신 `range[Symbol.iterator]()`를 호출해서 만든 ‘이터레이터’ 객체와 이 객체의 메서드 `next()`에서 반복에 사용될 값을 만들어낸다.

이렇게 하면 이터레이터 객체와 반복 대상인 객체를 분리할 수 있다.

이터레이터 객체와 반복 대상 객체를 합쳐서 `range` 자체를 이터레이터로 만들면 코드가 아래처럼 더 간단해진다.

```javascript
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
```

이제 `range[Symbol.iterator]()`가 객체 `range` 자체를 반환한다. 반환된 객체엔 필수 메서드인 `next()`가 있고 `this.current`에 반복이 얼마나 진행되었는지를 나타내는 값도 저장되어 있다. 코드는 더 짧아졌고 이렇게 작성하는 게 좋을 때가 종종 있다.

단점은 두 개의 `for..of` 반복문을 하나의 객체에 동시에 사용할 수 없다는 점이다. 이터레이터(객체 자신)가 하나뿐이어서 두 반복문이 반복 상태를 공유하기 때문이다. 그런데 동시에 두 개의 `for..of`를 사용하는 것은 비동기 처리에서도 흔한 케이스는 아니다.



**무한개의 이터레이터**

무수히 많은 이터레이터도 가능하다. `range`에서 `range.to`에 `Infinity`를 할당하면 `range`가 무한대가 되죠. 무수히 많은 의사 난수(pseudorandom numbers)를 생성하는 이터러블 객체를 만드는 것도 가능하다. 이 방법이 유용하게 쓰이는 경우도 있다.

`next`엔 제약사항이 없다. `next`가 값을 계속 반환하는 것은 정상적인 동작이다.

물론 위와 같은 이터러블에 `for..of` 반복문을 사용하면 끝이 없을 거다. 그렇다 하더라도 `break`를 사용하면 언제든지 반복을 멈출 수 있다.



#### 문자열은 이터러블이다

배열과 문자열은 가장 광범위하게 쓰이는 내장 이터러블이다.

`for..of`는 문자열의 각 글자를 순회한다.

```javascript
for (let char of "test") {
  // 글자 하나당 한 번 실행됩니다(4회 호출).
  alert( char ); // t, e, s, t가 차례대로 출력됨
}
```



서로게이트 쌍(surrogate pair)에도 잘 동작한다.

```javascript
let str = '𝒳😂';
for (let char of str) {
    alert( char ); // 𝒳와 😂가 차례대로 출력됨
}
```





#### 이터레이터를 명시적으로 호출하기

 `for..of`를 사용했을 때와 동일한 방법으로 문자열을 순회할 건데, 이번엔 직접 호출을 통해서 순회해보자. 다음 코드는 문자열 이터레이터를 만들고, 여기서 값을 ‘수동으로’ 가져온다.

```javascript
let str = "Hello";

// for..of를 사용한 것과 동일한 작업을 한다.
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // 글자가 하나씩 출력된다.
}
```

이터레이터를 명시적으로 호출하는 경우는 거의 없는데, 이 방법을 사용하면 `for..of`를 사용하는 것보다 반복 과정을 더 잘 통제할 수 있다는 장점이 있다. 반복을 시작했다가 잠시 멈춰 다른 작업을 하다가 다시 반복을 시작하는 것과 같이 반복 과정을 여러 개로 쪼개는 것이 가능하다.



#### 이터러블과 유사 배열

비슷해 보이지만 아주 다른 용어 두 가지가 있다. 헷갈리지 않으려면 두 용어를 잘 이해하고 있어야 한다.

- *이터러블(iterable)* 은 위에서 설명한 바와 같이 메서드 `Symbol.iterator`가 구현된 객체이다.
- *유사 배열(array-like)* 은 인덱스와 `length` 프로퍼티가 있어서 배열처럼 보이는 객체이다.

브라우저나 등의 호스트 환경에서 자바스크립트를 사용해 문제를 해결할 때 이터러블 객체나 유사 배열 객체 혹은 둘 다인 객체를 만날 수 있다.

이터러블 객체(`for..of` 를 사용할 수 있음)이면서 유사배열 객체(숫자 인덱스와 `length` 프로퍼티가 있음)인 문자열이 대표적인 예이다.

이터러블 객체라고 해서 유사 배열 객체는 아니다. 유사 배열 객체라고 해서 이터러블 객체인 것도 아니다.

위 예시의 `range`는 이터러블 객체이긴 하지만 인덱스도 없고 `length` 프로퍼티도 없으므로 유사 배열 객체가 아니다.

아래 예시의 객체는 유사 배열 객체이긴 하지만 이터러블 객체가 아니다.

```javascript
let arrayLike = { // 인덱스와 length프로퍼티가 있음 => 유사 배열
  0: "Hello",
  1: "World",
  length: 2
};

// Symbol.iterator가 없으므로 에러 발생
for (let item of arrayLike) {}
```

이터러블과 유사 배열은 대개 *배열이 아니기 때문에* `push`, `pop` 등의 메서드를 지원하지 않는다. 이터러블과 유사 배열을 배열처럼 다루고 싶을 때 이런 특징은 불편함을 초래한다. `range`에 배열 메서드를 사용해 무언가를 하고 싶을 때처럼 말이다. 어떻게 하면 이터러블과 유사 배열에 배열 메서드를 적용할 수 있을까?



#### Array.from

범용 메서드 [Array.from](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from)는 이터러블이나 유사 배열을 받아 ‘진짜’ `Array`를 만들어준다. 이 과정을 거치면 이터러블이나 유사 배열에 배열 메서드를 사용할 수 있다.



```javascript
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (메서드가 제대로 동작한다.)
```

`(*)`로 표시한 줄에 있는 `Array.from`은 객체를 받아 이터러블이나 유사 배열인지 조사한다. 넘겨 받은 인수가 이터러블이나 유사 배열인 경우, 새로운 배열을 만들고 객체의 모든 요소를 새롭게 만든 배열로 복사한다.

이터러블을 사용한 예시는 다음과 같다.

```javascript
// range는 챕터 위쪽 예시에서 그대로 가져왔다고 가정하자.
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 (배열-문자열 형 변환이 제대로 동작한다.)
```



`Array.from`엔 ‘매핑(mapping)’ 함수를 선택적으로 넘겨줄 수 있다.

```javascript
Array.from(obj[, mapFn, thisArg])
```

`mapFn`을 두 번째 인수로 넘겨주면 새로운 배열에 `obj`의 요소를 추가하기 전에 각 요소를 대상으로 `mapFn`을 적용할 수 있다. 새로운 배열엔 `mapFn`을 적용하고 반환된 값이 추가된다. 세 번째 인수 `thisArg`는 각 요소의 `this`를 지정할 수 있도록 해준다.



```javascript
// range는 챕터 위쪽 예시에서 그대로 가져왔다고 가정하자.

// 각 숫자를 제곱
let arr = Array.from(range, num => num * num);

alert(arr); // 1,4,9,16,25
```

아래 예시에선 `Array.from`를 사용해 문자열을 배열로 만들어보았다.

```javascript
let str = '𝒳😂';

// str를 분해해 글자가 담긴 배열로 만듦
let chars = Array.from(str);

alert(chars[0]); // 𝒳
alert(chars[1]); // 😂
alert(chars.length); // 2
```

`Array.from`은 `str.split`과 달리, 문자열 자체가 가진 이터러블 속성을 이용해 동작한다. 따라서 `for..of`처럼 서로게이트 쌍에도 제대로 적용된다.

위 예시는 기술적으로 아래 예시와 동일하게 동작한다고 보면 된다.

```javascript
let str = '𝒳😂';

let chars = []; // Array.from 내부에선 아래와 동일한 반복문이 돌아간다.
for (let char of str) {
  chars.push(char);
}

alert(chars);
```

어쨌든 `Array.from`을 사용한 예시가 더 짧다.

`Array.from`을 사용하면 서로게이트 쌍을 처리할 수 있는 `slice`를 직접 구현할 수도 있다.

```javascript
function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = '𝒳😂𩷶';

alert( slice(str, 1, 3) ); // 😂𩷶

// 내장 순수 메서드는 서로게이트 쌍을 지원하지 않는다.
alert( str.slice(1, 3) ); // 쓰레깃값 출력 (영역이 다른 특수 값)
```





> #### 요약
>
> `for..of`을 사용할 수 있는 객체를 *이터러블*이라고 부른다.
>
> - 이터러블엔 메서드
>
>   ```
>   Symbol.iterator
>   ```
>
>   가 반드시 구현되어 있어야 한다.
>
>   - `obj[Symbol.iterator]`의 결과는 *이터레이터*라고 부른다. 이터레이터는 이어지는 반복 과정을 처리한다.
>   - 이터레이터엔 객체 `{done: Boolean, value: any}`을 반환하는 메서드 `next()`가 반드시 구현되어 있어야 한다. 여기서 `done:true`은 반복이 끝났음을 의미하고 그렇지 않은 경우엔 `value`가 다음 값이 된다.
>
> - 메서드 `Symbol.iterator`는 `for..of`에 의해 자동으로 호출되는데, 개발자가 명시적으로 호출하는 것도 가능하다.
>
> - 문자열이나 배열 같은 내장 이터러블에도 `Symbol.iterator`가 구현되어 있다.
>
> - 문자열 이터레이터는 서로게이트 쌍을 지원한다.
>
> 인덱스와 `length` 프로퍼티가 있는 객체는 *유사 배열*이라 불린다. 유사 배열 객체엔 다양한 프로퍼티와 메서드가 있을 수 있는데 배열 내장 메서드는 없다.
>
> 명세서를 보면 대부분의 메서드는 ‘진짜’ 배열이 아닌 이터러블이나 유사 배열을 대상으로 동작한다고 쓰여 있는걸 볼 수 있다. 이 방법이 더 추상적이기 때문이다.
>
> `Array.from(obj[, mapFn, thisArg])`을 사용하면 이터러블이나 유사 배열인 `obj`를 진짜 `Array`로 만들 수 있다. 이렇게 하면 `obj`에도 배열 메서드를 사용할 수 있다. 선택 인수 `mapFn`와 `thisArg`는 각 요소에 함수를 적용할 수 있게 해준다.



