# 배열

## 배열 선언

아래 두 문법을 사용하면 빈 배열을 만들 수 있습니다.
대괄호안에 초기요소를 넣어주는 것도 가능합니다.
```
let arr = new Array();
let arr = [];


let fruits = ["사과", "오렌지", "자두"];
```

각 배열 요소엔 0부터 시작하는 숫자(인덱스)가 매겨져 있습니다. 이 숫자들은 배열 내 순서를 나타냅니다.
```
let fruits = ["사과", "오렌지", "자두"];

alert( fruits[0] ); // 사과
alert( fruits[1] ); // 오렌지
alert( fruits[2] ); // 자두
```

요소를 수정할 수도 있습니다.
```
fruits[2] = '배'; // 배열이 ["사과", "오렌지", "배"]로 바뀜
```

새로운 요소를 배열에 추가하는 것도 가능합니다.

```
fruits[3] = '레몬'; // 배열이 ["사과", "오렌지", "배", "레몬"]으로 바뀜
```

``` length ```를 사용하면 배열에 담긴 요소가 몇개인지 알아낼수 있습니다.

```
let fruits = ["사과", "오렌지", "자두"];

alert( fruits.length ); // 3
``` 
배열 요소의 자료형엔 제약이 없습니다.
```// 요소에 여러 가지 자료형이 섞여 있습니다.
let arr = [ '사과', { name: '이보라' }, true, function() { alert('안녕하세요.'); } ];

// 인덱스가 1인 요소(객체)의 name 프로퍼티를 출력합니다.
alert( arr[1].name ); // 이보라

// 인덱스가 3인 요소(함수)를 실행합니다.
arr[3](); // 안녕하세요.
```

``` 
let fruits = [ 
  "사과",
  "오렌지",
  "자두",
]; 
```
> 배열의 마지막 요소는 객체와 마찬가지로 쉼표로 끝날 수 있습니다.
> trailing(길게 늘어지는) 쉼표를 사용하면 모든 줄의 생김새가 유사해지기 때문에 요소를 넣거나 빼기가 쉬워집니다.


## pop,push 와 shift,unshift

- push : 요소를 끝에 스택에 집어넣습니다.
- pop : 스택 끝 요소를 추출합니다.
- shift : 배열 앞 요소를 제거하고, 제거한 요소를 반환합니다.
- unshift : 배열앞에 요소를 추가합니다.

**스택을 사용하면 가장 나중에 집어넣은 요소가 먼저 나옵니다. 이런 특징을 줄여서 후입선출(Last-In-First-Out, LIFO)이라고 부릅니다. 반면 큐를 사용하면 먼저 집어넣은 요소가 먼저 나오기 때문에 큐는 선입선출(First-In-First-Out, FIFO) 자료구조라고 부릅니다.**

자바스크립트 pop,push,shift,unshift를 적절하게 사용하면 큐와 스택 둘 다를 만들 수 있습니다. 
예를들어 Queue 기능으로 동작하고 싶을땐 push() 와 shift() 함수를 사용하면 되고, Stack 기능으로 동작하고 싶을땐 push()와 pop() 함수를 사용하면 됩니다.

```
1. pop

let fruits = ["사과", "오렌지", "배"];
alert( fruits.pop() ); // 배열에서 "배"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.
alert( fruits ); // 사과,오렌지

2.push
let fruits = ["사과", "오렌지"];
fruits.push("배");
alert( fruits ); // 사과,오렌지,배

3.shift
let fruits = ["사과", "오렌지", "배"];
alert( fruits.shift() ); // 배열에서 "사과"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.
alert( fruits ); // 오렌지,배

4.unshift
let fruits = ["오렌지", "배"];
fruits.unshift('사과');
alert( fruits ); // 사과,오렌지,배
```


## 배열의 내부 동작 원리
배열은 특별한 종류의 객체입니다. 배열 arr의 요소를 arr[0]처럼 대괄호를 사용해 접근하는 방식은 객체 문법에서 왔습니다. 
다만 배열은 키가 숫자라는 점만 다릅니다.
배열은 객체와 마찬가지로 참조를 통해 복사됩니다.

```
let fruits = ["바나나"]
let arr = fruits; // 참조를 복사함(두 변수가 같은 객체를 참조)
alert( arr === fruits ); // true
arr.push("배"); // 참조를 이용해 배열을 수정합니다.
alert( fruits ); // 바나나,배 - 요소가 두 개가 되었습니다
```
 자바스크립트 엔진은 아래쪽 그림에서처럼 배열의 요소를 인접한 메모리 공간에 차례로 저장해 연산 속도를 높입니다. 이 방법 이외에도 배열 관련 연산을 더 빠르게 해주는 최적화 기법은 다양합니다.
 **그러나,개발자가 배열을 '순서가 있는 자료의 컬렉션’처럼 다루지 않고 일반 객체처럼 다루면 이런 기법들이 제대로 동작하지 않습니다.** 
 
 ```
 let fruits = []; // 빈 배열을 하나 만듭니다.
fruits[99999] = 5; // 배열의 길이보다 훨씬 큰 숫자를 사용해 프로퍼티를 만듭니다.
fruits.age = 25; // 임의의 이름을 사용해 프로퍼티를 만듭니다.
 ```
 문제가 생기지는 않으나, 배열을 다룰때만 적용되는 최적화 기법이 동작하지 않아 배열 특유의 이점이 사라진다.

## 성능

push,pop은 빠르지만 shift,unshift는 느립니다.
shift 메서드를 호출한 것과 동일한 효과를 보려면 인덱스가 0인 요소를 제거하는 것만으론 충분하지 않습니다. 제거 대상이 아닌 나머지 요소들의 인덱스를 수정해 줘야 하죠.

<img width="531" alt="스크린샷 2021-05-27 오후 9 23 07" src="https://user-images.githubusercontent.com/62633444/119825264-bc657300-bf31-11eb-8de4-8c7afd36855e.png">

1. 인덱스가 0인 요소를 제거합니다.
2. 모든 요소를 왼쪽으로 이동시킵니다. 이때 인덱스 1은 0, 2는 1로 변합니다.
3. length 프로퍼티 값을 갱신합니다.

**배열에 요소가 많으면 요소가 이동하는 데 걸리는 시간이 길고 메모리 관련 연산도 많아집니다.**
unshift를 실행했을 때도 이와 유사한 일이 일어납니다. 요소를 배열 앞에 추가하려면 일단 기존 요소들을 오른쪽으로 이동시켜야 하는데, 이때 인덱스도 바꿔줘야 합니다.

pop 메서드로 요소를 끝에서 제거하려면 마지막 요소를 제거하고 length 프로퍼티의 값을 줄여주기만 하면 됩니다.
<img width="531" alt="스크린샷 2021-05-27 오후 9 24 08" src="https://user-images.githubusercontent.com/62633444/119825407-e0c14f80-bf31-11eb-8fa4-1148dd5f6a5d.png">
push메서드도 유사한 동작이 일어나므로 속도가 빠릅니다.

## 반복문

1.for문 - 가장오래된 방법
```
let arr = ["사과", "오렌지", "배"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
```

2.for..of
```
let fruits = ["사과", "오렌지", "자두"];

// 배열 요소를 대상으로 반복 작업을 수행합니다.
for (let fruit of fruits) {
  alert( fruit );
}
```
for..of를 사용하면 현재 요소의 인덱스는 얻을 수 없고 값만 얻을 수 있습니다.

3. for..in

```
let arr = ["사과", "오렌지", "배"];

for (let key in arr) {
  alert( arr[key] ); // 사과, 오렌지, 배
}
```
- for..in을 안써야하는 이유
1. for..in 반복문은 모든 프로퍼티를 대상으로 순회합니다. 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함됩니다. 배열 객체엔 배열과는 달리 키가 숫자형이 아닌 프로퍼티와 메서드가 있을 수 있습니다. 유사 배열 객체와 for..in을 함께 사용하면 이 모든 것을 대상으로 순회가 이뤄집니다. 따라서 ‘필요 없는’ 프로퍼티들이 문제를 일으킬 가능성이 생깁니다.
2. for..in 반복문은 배열이 아니라 객체와 함께 사용할 때 최적화되어 있어서 배열에 사용하면 객체에 사용하는 것 대비 10~100배 정도 느립니다. 

## 'lenght' 프로퍼티

length 프로퍼티는 배열 내 요소의 개수가 아니라 가장 큰 인덱스에 1을 더한 값입니다.

```
let fruits = [];
fruits[123] = "사과";

alert( fruits.length ); // 124 
```
length의 값을 수동으로 증가시키면 아무 일도 일어나지 않습니다. 
그런데 값을 감소시키면 배열이 잘립니다. 짧아진 배열은 다시 되돌릴 수 없습니다. 예시를 통해 이를 살펴봅시다.
```
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // 요소 2개만 남기고 잘라봅시다.
alert( arr ); // [1, 2]

arr.length = 5; // 본래 길이로 되돌려 봅시다.
alert( arr[3] ); // undefined: 삭제된 기존 요소들이 복구되지 않습니다.
```

## new Array()

```new Array()``` 문법을 사용해도 배열을 만들 수 있습니다.
대괄호 []를 사용하면 더 짧은 문법으로 배열을 만들 수 있기 때문에 new Array()는 잘 사용되지 않는 편입니다.
new Array()엔 다루기 까다로운 기능도 있어서 더욱더 그렇습니다.

숫자형 인수 하나를 넣어서 new Array를 호출하면 배열이 만들어지는데, 이 배열엔 요소가 없는 반면 길이는 인수와 같아집니다.
예시를 통해 new Array()의 이런 특징이 어떻게 실수를 유발할 수 있는지 알아봅시다.

```
let arr = new Array(2); // 이렇게 하면 배열 [2]가 만들어질까요?

alert( arr[0] ); // undefined가 출력됩니다. 요소가 하나도 없는 배열이 만들어졌네요.

alert( arr.length ); // 길이는 2입니다.
```


## 다차원 배열
배열 역시 배열의 요소가 될 수 있습니다. 이런 배열을 가리켜 다차원 배열(multidimensional array)이라 부릅니다. 다차원 배열은 행렬을 저장하는 용도로 쓰입니다.

```
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5, 중심에 있는 요소
```

## toString

배열엔 toString 메서드가 구현되어 있어 이를 호출하면 요소를 쉼표로 구분한 문자열이 반환됩니다.
```
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true

alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
```

-> 배열엔 Symbol.toPrimitive나 valueOf 메서드가 없습니다. 
따라서 위 예시에선 문자열로의 형 변환이 일어나 []는 빈 문자열, [1]은 문자열 "1", [1,2]는 문자열 "1,2"로 변환됩니다.
