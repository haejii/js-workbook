# 화살표 함수 다시 알아보기 
## 화살표 함수에는 'this'가 없다. 
화살표 함수본문에서 this를 접근하면, 외부에서 갑을 가져온다. 


``` jsx
let group = {
    title: "1모둠",
    students: ["보라", "호진", "지민"],
  
    showList() {
      this.students.forEach(
        student => console.log(this.title + ': ' + student)
      );
    }
  };
  
  group.showList();
  ```

  위의 경우는 forEach에서 화살표 함수를 사용했기 때문에 화살표 함수 본문에 있는 this.title은 화살표 함수 바깥에 있는 메서드인 showList가 가리키는 대상과 동일해진다. 즉, this.title은 groub.title과 같다. 

  만약 일반 함수를 사용할 시
  ``` jsx
  let group = {
  title: "1모둠",
  students: ["보라", "호진", "지민"],

  showList() {
    this.students.forEach(function(student) {
      // TypeError: Cannot read property 'title' of undefined
      alert(this.title + ': ' + student)
    });
  }
};

group.showList();
``` 
에러가 발생한다.

why?
위에선 this가 undefined여서 undefied.title에 접근하려하니 에러가 출력되는 것!


## 화살표 함수는 new와 함께 실행할 수 없다. 
this가 없기 때문에 생성자 함수로 사용할 수 없다.


## 화살표 함수엔 'arguments'가 없습니다. 
화살표 함수는 일반 함수와는 다르게 모든 인수에 접근할 수 있게 해주는 유사배열 객체 argument를 지원하지 않는다. 

이런 특징은 현재 this 값과 arguments 정보를 함께 실어 호출을 포워딩해 주는 데코레이터를 만들 대 유용하게 사용된다. 

아래 예시에는 데코레이터 defer(f, ms)는 함수를 인자로 받고 이 함수를 래퍼로 감싸 반화하는데, 함수 f는 ms 밀리초 후에 호출된다. 

```jsx
function defer(f, ms) {
    return function() {
      setTimeout(() => f.apply(this, arguments), ms)
    };
  }
  
  function sayHi(who) {
    console.log('안녕, ' + who);
  }
  
  let sayHiDeferred = defer(sayHi, 2000);
  sayHiDeferred("철수"); // 2초 후 "안녕, 철수"가 출력됩니다.
  ```
 화살표 함수가 닐 시 일반 함수에선 setTImeout에 넘겨주는 콜백함수에서 사용할 변수 ctx와 args를 반드시 만들어줘야 한다. 

 ``` jsx
 function defer(f, ms) {
  return function(...args) {
    let ctx = this;
    setTimeout(function() {
      return f.apply(ctx, args);
    }, ms);
  };
}
```
