# 객체로서의 함수와 기명 함수 표현식
함수의 자료형은 무엇일까? 
=>  함수는 객체이다. 함수는 호출 가능한 행동 객체로 이해하면 이해하면쉽ㄴ다. 

객체처럼 함수에 프로퍼티르 ㄹ추가.제거하거나 참조를 통해 전달도 가능하다. 

## 'name'프로퍼티
함수의 이름 가져오기 
``` jsx
function sayHi(){
    console.log('Hi');
}

console.log(sayHi.name); // sayHi
```

?? 함수 이름을 sayHi인데 이걸 호출하면 이미 함수이름을 알고 있는거 아닌가;;;;


익명함수도 자동으로 이름할당

``` jsx
let sayHo = function(){
    console.log("Hi");
}
console.log(sayHi.name); // sayHi
```


기본값을 사용해 이름을 할당한 경우도 마찬가지다. 

``` jsx
function f(sayHi = function() {}) {
  alert(sayHi.name); // sayHi (이름이 있네요!)
}

f();
```

자바스크립트 명세서에서 정의된 이 기능을 'contextual name'이라고 부른다. 

객체 메서드의 이름 가져오기 
``` jsx

let user = {

  sayHi() {
    // ...
  },

  sayBye: function() {
    // ...
  }

}

alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye
```

객체 메서드 이름은 함수처럼 자동할당이 되지 않는다.

적절한 이름을 추론하는게 불가능한 상황이 있는데, 이때 name프로퍼티엔 빈 문자열이 저장된다. 

``` jsx
// 배열 안에서 함수를 생성함
let arr = [function() {}];

alert( arr[0].name ); // <빈 문자열>
// 엔진이 이름을 설정할 수 없어서 name 프로퍼티의 값이 빈 문자열이 됨
```

## 'length' 프로퍼티

함수 프로퍼티의 매개변수 개수 반환
``` jsx
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2
```

이때 나머지 매개 변수는 개수에 포함되지 안는다. 
```jsx
function ask(question, ...handlers) {
  let isYes = confirm(question);
  for (let handler of handlers) {
    if (handler.length == 0) {
      if (isYes) handler();
    } else {
      handler(isYes);
    }
  }
}

// 사용자가 OK를 클릭한 경우, 핸들러 두 개를 모두 호출함
// 사용자가 Cancel을 클릭한 경우, 두 번째 핸들러만 호출함
ask(
  "질문 있으신가요?",
  () => alert("OK를 선택하셨습니다."),
  (result) => alert(result)
);
```

## 커스텀 프로퍼티
함수에 자체적으로 만든 프로퍼티를 추가할 수 있다. 
```jsx
function sayHi() {
  console.log("Hi");

  // 함수를 몇 번 호출했는지 세봅시다.
  sayHi.counter++;
}
sayHi.counter = 0; // 초깃값

sayHi(); // Hi
sayHi(); // Hi

console.log( `호출 횟수: ${sayHi.counter}회` ); // 호출 횟수: 2회
```

## 기명 함수 표현식
``` jsx
let sayHi = function(who){
    console.log(`Hello, ${who}`);
}
```


<hr/>

# new Function 문법

## new Function으로 함수 만들기 

``` jsx
let func = new Function([arg1, arg2, ...argN], functionBody);
```
