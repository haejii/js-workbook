# 재귀와 스택

## 두가지 사고 방식
ex)

``` jsx
pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16;
```
구현해보기 

1. 반복문: for루프
``` jsx
function pos(x, n){
    let result = 1;

    for(let i=0; i<n; i++){s
        result *= x;
    }

    return result;
}

console.log(por(2, 3)); // 8
```

2. 재귀적인 사고를 통한 방법: 자기 자신을 호출

``` jsx
function pos(x, n){
    if(n == 1){
        return x;
    }else{
        return x * pow(x, n-1);
    }
}

console.log(pow(2, 3))

```
자바스크립트 엔진은 최대 재귀 깊이를 제한한다. 
만개 정도까진 확실히 허용하고, 엔진에 따라 이보다 더 많은 깊이를 허용하는 경우도 있다. 
하지만 대 다수의 엔진이 십만까지는 다루지 못한다. 

완화하기 위해서 => 엔진 내부에서 자동으로 'tail calls optimization'이라는 최적화를 수행하기는 하지만 모든 곳에 적용되는 것은 아니고 간단한 경우에만 적용된다. 

## 실행 컨텍스트와 스택
실제 제귀 호출이 어떻게 동작될까?
실행중인 함수의 실행 절차에 대한 정보는 해당 함수의 실행 컨텍스트에 저장된다. 

실행 컨텍스트: 함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조

제어 흐름의 현재 위치, 변수의 현재 값, this의 값 등 상세 내부 정보가 실행 컨텍스트에 저장된다. 

함수 내부에 중첩 호출이 있을 댸 절차
1. 현재 함수의 실행이 일시 중지 
2. 중지된 함수와 연관된 실행컨텍스트는 실행컨텍스트 스택이라는 특별한 자료 구조에 저장
3. 중첩 호출이 실행
4. 중첩 호출 실행이 끝난 이후 실행 컨텍스트 스택에서 일시 중단한 함수의 실행 컨텍스트를 꺼내오고, 중단한 함수의 실행을 다시 이어감

실행 컨텍스트는 메모리를 차지하므로 재귀를 사용할 땐 메모리 요구사항에 유의해야한다. 
 n을 늘리면 n이 줄어들 때마다 만들어지는 n개의 실행 컨텍스트가 저장될 메모리 공간이 필요하기 때문이다. 

 반복문 기반 알고리즘을 사용하면 메모리가 절약된다. 
 ``` jsx
 function pow(x, n){
     let result = 1;

     for(let i=0; i<n; i++){
         result *= x;
     }

     return result;
 }
 ```
그렁에도 불구하고 재귀를 사용하는 이유는 코드가 짧아지고 코드 이해도가 높아지며 유지보수에도 이점이 있기에

## 재귀적 순회
```jsx
let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};
```

``` jsx
let company = {
    sales: [{
      name: 'John',
      salary: 1000
    }, {
      name: 'Alice',
      salary: 1600
    }],
  
    development: {
      sites: [{
        name: 'Peter',
        salary: 2000
      }, {
        name: 'Alex',
        salary: 1800
      }],
  
      internals: [{
        name: 'Jack',
        salary: 1300
      }]
    }
  };

  //급여구하기 함수
  function sumSalaries(department){
      if(Array.isArray(department)){
          return department.reduce((prev, current)=>prev+current.salary ,0); 
      }else{
          let sum = 0;
          for(let subdep of Object.values(department)){
              sum += sumSalaries(subdep); // 재귀 호출로 각 하위 부서 임직원의 급여 총 합을 구해준다. 
          }

          return sum;
      }
  }

  console.log(sumSalaries(company));
  ```

## 재귀적 구조
재귀적 구조: 자기 자신의 일부를 복재하는 형태의 자료 구조


### 연결리스트
객체를 어디에 저장하고 싶을 때 자료구조로 배열을 많이 쓴다. 하지만 삭제와 삽입시 들어가는 비용이 크다. 

빠르게 배열을 삽입 혹은 삭제를 할떄는 연결리스트라고 불리는 자료구조를 사용할 수 있다. 

연결리스트의 요소

value, next: 다음 연결 리스트 요소를 참조하는 프로퍼티, 다음 요소가 없으면 null

연결리스트 작성법 

1)
``` jsx
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
```


2)
``` jsx
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;
```

연결리스트 나누기 
``` jsx
let secondList = list.next.next;
list.next.next = null;
```

합치기
``` jsx
list.next.next = secondList;
```

처음 객체 바꿔서 새로운 값 추가하기
``` jsx
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

// list에 새로운 value를 추가합니다.
list = { value: "new item", next: list };
```

중간요소 제거하기 (이전 요소의 next를 변경)
``` jsx
list.next = list.next.next;
```

연결리스트의 단점 번호(인덱스)만 사용해 요소에 접근할 수 없다는 점



<hr/>
