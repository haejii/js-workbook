# 재귀와 스택

## 두가지 사고 방식
ex)

``` jsx
pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16;
```
구현해보기 

1. 반복문: for루프
``` jsx
function pos(x, n){
    let result = 1;

    for(let i=0; i<n; i++){s
        result *= x;
    }

    return result;
}

console.log(por(2, 3)); // 8
```

2. 재귀적인 사고를 통한 방법: 자기 자신을 호출

``` jsx
function pos(x, n){
    if(n == 1){
        return x;
    }else{
        return x * pow(x, n-1);
    }
}

console.log(pow(2, 3))

```
자바스크립트 엔진은 최대 재귀 깊이를 제한한다. 
만개 정도까진 확실히 허용하고, 엔진에 따라 이보다 더 많은 깊이를 허용하는 경우도 있다. 
하지만 대 다수의 엔진이 십만까지는 다루지 못한다. 

완화하기 위해서 => 엔진 내부에서 자동으로 'tail calls optimization'이라는 최적화를 수행하기는 하지만 모든 곳에 적용되는 것은 아니고 간단한 경우에만 적용된다. 

## 실행 컨텍스트와 스택
실제 제귀 호출이 어떻게 동작될까?
실행중인 함수의 실행 절차에 대한 정보는 해당 함수의 실행 컨텍스트에 저장된다. 

실행 컨텍스트: 함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조

제어 흐름의 현재 위치, 변수의 현재 값, this의 값 등 상세 내부 정보가 실행 컨텍스트에 저장된다. 

함수 내부에 중첩 호출이 있을 댸 절차
1. 현재 함수의 실행이 일시 중지 
2. 중지된 함수와 연관된 실행컨텍스트는 실행컨텍스트 스택이라는 특별한 자료 구조에 저장
3. 중첩 호출이 실행
4. 중첩 호출 실행이 끝난 이후 실행 컨텍스트 스택에서 일시 중단한 함수의 실행 컨텍스트를 꺼내오고, 중단한 함수의 실행을 다시 이어감

실행 컨텍스트는 메모리를 차지하므로 재귀를 사용할 땐 메모리 요구사항에 유의해야한다. 
 n을 늘리면 n이 줄어들 때마다 만들어지는 n개의 실행 컨텍스트가 저장될 메모리 공간이 필요하기 때문이다. 

 반복문 기반 알고리즘을 사용하면 메모리가 절약된다. 
 ``` jsx
 function pow(x, n){
     let result = 1;

     for(let i=0; i<n; i++){
         result *= x;
     }

     return result;
 }
 ```
그렁에도 불구하고 재귀를 사용하는 이유는 코드가 짧아지고 코드 이해도가 높아지며 유지보수에도 이점이 있기에

## 재귀적 순회
```jsx
let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};
```

``` jsx
let company = {
    sales: [{
      name: 'John',
      salary: 1000
    }, {
      name: 'Alice',
      salary: 1600
    }],
  
    development: {
      sites: [{
        name: 'Peter',
        salary: 2000
      }, {
        name: 'Alex',
        salary: 1800
      }],
  
      internals: [{
        name: 'Jack',
        salary: 1300
      }]
    }
  };

  //급여구하기 함수
  function sumSalaries(department){
      if(Array.isArray(department)){
          return department.reduce((prev, current)=>prev+current.salary ,0); 
      }else{
          let sum = 0;
          for(let subdep of Object.values(department)){
              sum += sumSalaries(subdep); // 재귀 호출로 각 하위 부서 임직원의 급여 총 합을 구해준다. 
          }

          return sum;
      }
  }

  console.log(sumSalaries(company));
  ```

## 재귀적 구조
재귀적 구조: 자기 자신의 일부를 복재하는 형태의 자료 구조


### 연결리스트
객체를 어디에 저장하고 싶을 때 자료구조로 배열을 많이 쓴다. 하지만 삭제와 삽입시 들어가는 비용이 크다. 

빠르게 배열을 삽입 혹은 삭제를 할떄는 연결리스트라고 불리는 자료구조를 사용할 수 있다. 

연결리스트의 요소

value, next: 다음 연결 리스트 요소를 참조하는 프로퍼티, 다음 요소가 없으면 null

연결리스트 작성법 

1)
``` jsx
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
```


2)
``` jsx
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;
```

연결리스트 나누기 
``` jsx
let secondList = list.next.next;
list.next.next = null;
```

합치기
``` jsx
list.next.next = secondList;
```

처음 객체 바꿔서 새로운 값 추가하기
``` jsx
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

// list에 새로운 value를 추가합니다.
list = { value: "new item", next: list };
```

중간요소 제거하기 (이전 요소의 next를 변경)
``` jsx
list.next = list.next.next;
```

연결리스트의 단점 번호(인덱스)만 사용해 요소에 접근할 수 없다는 점



<hr/>


# 나머지 매개변수와 전개 문법

## 나머지 매개 변수 ...
함수 정의 방법과 상관없이 함수에 넘겨주는 인수 개수엔 제약이 없다. 

``` jsx
function sum(a, b){
  return a+b;
}

console.log(sum(1, 2, 3, 4, 5))
```
 정의 시 인수를 두개만 받게했지만 이렇게 넣어도 문제는 없다. 

 하지만 반환값은 처음에 넘겨주는 두 개의 인수만을 사용하게 된다. 

 하지만 위에 처럼 여러개의 변수를 모두 사용하고 싶은면 어떻할까?

 ...을 사용한다. ("나머지 매개변수들을 한데 모아 배열에 집어 넣으라는 뜻)

 ``` jsx
function sumAll(...args) { // args는 배열의 이름입니다.
  let sum = 0;

  for (let arg of args) sum += arg;

  return sum;
}
console.log(sumAll(1)); //1 
console.log(sumAll(1, 2)); //3 
console.log(sumAll(1, 2, 3)); //6
```

```jsx

function showName(firstName, lastName, ...titles) {
  console.log( firstName + ' ' + lastName ); // Julius Caesar

 // 나머지 인수들은 배열 titles의 요소가 된다. 
 // titles = ["Consul", "Imperator"]
  console.log(titles[0]);// Consul
  console.log(titles[1]);// Imperator
  console.log(titles.length); //2
}

showName("Julius", "Caesar", "Consul", "Imperator");
```

주의할점!!
나머지 변수는 항상 마지막에 있어야 한다. 
```  jsx
function f(arg1, ...rest, arg2) { // ...rest 후에 arg2가 있으면 안 됩니다.
  // 에러
}
```


## 'arguments'변수

arguemnts라는 특별한 유사 배열 객체(array-like object)를 사용하면 인덱스를 사용하여 모든 인수에 접근이 가능하다. 

``` jsx
function showName() {
  console.log( arguments.length );
  console.log( arguments[0] );
  console.log( arguments[1] );

  // arguments는 이터러블 객체이기 때문에
  // for(let arg of arguments) alert(arg); 를 사용해 인수를 나열할 수 있습니다.
}

// 2, Julius, Caesar가 출력됨
showName("Julius", "Caesar");

// 1, Bora, undefined가 출력됨(두 번째 인수는 없음)
showName("Bora");
```

arguments 유사배열객체이면서 이터러블(반복 가능한)객체이다.

배열은 아님 그래서 배열 메소드는 사용할 수 없다. 

또한 인수 전체를 남기때문에 나머지 매개변수 처럼 인수의 일부를 사용할 수 없다. 

주의할점!
화살표함수에는 argument가 없다. 
```jsx
function f() {
  let showArg = () => alert(arguments[0]);
  showArg();
}

f(1); // 1
```

## spread 문법

Math.max : 인수로 받은 숫자 중 가장 큰 숫자를 반환
``` jsx 
console.log(Math.max(3, 5, 1)); // 5
```

하지만 이때 Math.max에 배열을 넣으면 동작하지 않는다. (Math.max는 배열이 아닌 숫자 목록을 받기 때문에)

``` jsx
let arr = [3, 5, 1];

alert( Math.max(arr) ); // NaN
```

그럼 어떻하지?

Math.max(arr[0], arr[1], arr[2])처럼 수동으로 나열해서 넣기?

=> 배열의 길이를 알 수 없을때는 어떻하지..?, 그리고 배열이 너무 많으면 지저분

해결법=> 전개분법...사용

...arr를 이용하면 이터러블 객체 arr이 인수 목록으로 '확장'됨

``` jsx
let arr = [3, 5, 1];

console.log(Math.max(...arr));// 5 (전개 문법이 배열을 인수 목록으로 바꿔주었습니다.)
```

이터러블 객체를 여러개 전달하기

``` jsx
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

console.log( Math.max(...arr1, ...arr2) ); // 8
```

전개 문법과 평범한 값 혼합해서 사용하기 
``` jsx
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

console.log( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
```

전개문법을 활용하여 배열 합치기 
``` jsx
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

let merged = [0, ...arr, 2, ...arr2];

console.log(merged); // 0,3,5,1,2,8,9,15 (0, arr, 2, arr2 순서로 합쳐집니다.)
```

배열이 아니여도 이터러블 객체이면 전개 문법이 사용가능하다. 

```jsx
let str = "Hello";
console.log([...str]);// H,e,l,l,o
```

전개 문법은 for..of와 같은 방식으로 내부에서 iterator(반복자)를 사용해 요소를 수집한다. 

