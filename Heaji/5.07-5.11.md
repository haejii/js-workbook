# 워크맵과 워크셋
자바스크립트 엔진은 도달 가능한 값을 메모리에 유지 한다. 
ex)
``` jsx
let john = {name: "John"};
// 위 객체는 john이라는 참조를 통해 접근 할 수 있다. 

// 그런데 참조를 null로 덮어쓰면 위 객체에 더 이상 도달이 가능하지 않게되어
john = null;

// 객체가 메모리에서 삭제된다. 
```

자료구조를 구성하는 요소도 자신이 속한 자료구조가 메모리에 남아있는 동안 대개 도달 가능한 값으로 취급되어 메모리에서 삭제되지 않는다. 

객체의 프로퍼티나 배열의 요소, 맵이나 셋을 구성하는 요소들이 이에 해당한다. 

``` jsx
let john = {name: "John"};
let array = [john];

john = null; // 참조를 null로 덥어씀. 
// john을 나타내는 객체는 배열의 요소이기 때문에 가비지 컬렉터의 대상이 되지 않습니다.
// array[0]을 이용하면 해당 객체를 얻는 것도 가능합니다.
console.log(john); //null
console.log(JSON.stringify(array[0])); //{"name":"John"}
```

맵에서 객체를 키로 사용한 경우 역시, 맵이 메모리에 있는 한 객체도 메모리에 남는다. 즉, 가비지 컬렉터의 대상이 되지 않는다. 
 
``` jsx
let john = { name: "John" };

let map = new Map();
map.set(john, "...");

console.log(map); //Map { { name: 'John' } => '...' }

john = null;

for (let obj of map.keys()) {
  console.log(JSON.stringify(obj)); //{"name":"John"}
}

console.log(map.size); //1

```

워크맵은 일반 맵과 전혀 다른 양상을 보인다. 
워크맵을 사용하면 키로 쓰인 객체가 가비지 컬렉션의 대상이 된다. 

## 워크맵
맵과 워크맵의 첫번째 차이는 키가 반드시 객체여야 한다는 점이다. 
``` jsx
let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); //정상적으로 동작합니다(객체 키).

// 문자열("test")은 키로 사용할 수 없습니다.
weakMap.set("test", "Whoops"); // Error: Invalid value used as weak map key
```

워크맵의 키로 사용된 객체를 참조하는 것이 아무것도 없다면 해당 객체는 메모리와 워크맵에서 자동으로 삭제된다. 

``` jsx
let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // 참조를 덮어씀

// john을 나타내는 객체는 이제 메모리에서 지워집니다!
```

john을 나타내는 객체는 오로지 위크맵의 키로만 사용되고 있으므로, 참조를 덮어쓰게 되면 이 객체는 위크맵과 메모리에서 자동으로 삭제됩니다.

맵과 위크맵의 두 번째 차이는 위크맵은 반복 작업과 keys(), values(), entries() 메서드를 지원하지 않는다는 점입니다. 따라서 위크맵에선 키나 값 전체를 얻는 게 불가능합니다.

# Object.keys, values, entries
이 메서드들은 포괄적인 용도로 만들어졌기 때문에 메서드를 적용할 자료구조는 일련의 합의를 준수해야 합니다. 커스텀 자료구조를 대상으로 순회를 해야 한다면 이 메서드들을 쓰지 못하고 직접 메서드를 구현해야 합니다.

keys(), values(), entries()를 사용할 수 있는 자료 구조
- Map
- Set
- Array

## Objec.keys, values, entries
일반 객체에 사용할 수 있는 메서드들
- Object.keys(obj) : 객체의 키만 담은 배열을 반환
- Object.values(obj) : 객체의 값만 남은 배열을 반환
- Object.entries(obj) : [키, 값] 쌍을 담은 배열을 반환

차이
이 메서드들은 포괄적인 용도로 만들어졌기 때문에 메서드를 적용할 자료구조는 일련의 합의를 준수해야 합니다. 커스텀 자료구조를 대상으로 순회를 해야 한다면 이 메서드들을 쓰지 못하고 직접 메서드를 구현해야 합니다.

``` jsx
let user = {
  name: "John",
  age: 30,
};

console.log(Object.keys(user)); //[ 'name', 'age' ]
console.log(Object.values(user)); // [ 'John', 30 ]
console.log(Object.entries(user)); //[ [ 'name', 'John' ], [ 'age', 30 ] ]
```

``` jsx
let user = {
  name: "Violet",
  age: 30
};

// 값을 순회합니다.
for (let value of Object.values(user)) {
  console.log(value); // Violet과 30이 연속적으로 출력됨
}
```

* Object.keys, values, entries는 심볼형 프로퍼티를 무시한다. 
  for..in 반복문처럼, Object.keys, Object.values, Object.entries는 키가 심볼형인 프로퍼티를 무시합니다.

대개는 심볼형 키를 연산 대상에 포함하지 않는 게 좋지만, 심볼형 키가 필요한 경우엔 심볼형 키만 배열 형태로 반환해주는 메서드인 Object.getOwnPropertySymbols를 사용하면 됩니다. getOwnPropertySymbols 이외에도 키 전체를 배열 형태로 반환하는 메서드인 Reflect.ownKeys(obj)를 사용해도 괜찮습니다.

## 객체 변환하기 
객체엔 map, filter 같은 배열 전용 메서드를 사용할 수 없습니다.

하지만 Object.entries와 Object.fromEntries를 순차적으로 적용하면 객체에도 배열 전용 메서드 사용할 수 있습니다. 적용 방법은 다음과 같습니다.

1. Object.entries(obj)를 사용해 객체의 키-값 쌍이 요소인 배열을 얻습니다.
2. 1.에서 만든 배열에 map 등의 배열 전용 메서드를 적용합니다.
3. 2.에서 반환된 배열에 Object.fromEntries(array)를 적용해 배열을 다시 객체로 되돌립니다.

``` jsx
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrics = Object.fromEntries(
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);

console.log(doublePrics); //{ banana: 2, orange: 4, meat: 8 }

console.log(Array.isArray(doublePrics)); //false

```

왜 굳이 위에 방식을 택할까?
배열을 다시 객체로 바꿔 써야 할때 유용하기 때문

``` jsx
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrics = Object.entries(prices).map(([key, value]) => [
  key,
  value * 2,
]);

console.log(doublePrics); //[ [ 'banana', 2 ], [ 'orange', 4 ], [ 'meat', 8 ] ]
```

# 구조 분해 할당
구조분해 할당: 객체나 배열을 변수로 분해 할 수 있게 하는 특별한 문법

## 배열 분해하기 
``` jsx
// 이름과 성을 요소로 가진 배열
let arr = ["Bora", "Lee"];

// 구조 분해 할당을 이용해
// firstName엔 arr[0]을
// surname엔 arr[1]을 할당하였습니다.
let [firstName, surname] = arr;

console.log(firstName); // Bora
console.log(surname); // Lee
```

``` jsx
let [firstName, surname] = "Bora Lee".split(' ');
```

* 구조 분해 시 분해 대상은 수정 또는 파괴되지 않는다. 
* 쉼표를 사용해 요소 무시 가능하다. 
  
``` jsx
  // 두 번째 요소는 필요하지 않음
let [firstName, , title] = [
  "Julius",
  "Caesar",
  "Consul",
  "of the Roman Republic",
];

console.log(title);
```

* 할당 연산자 우측엔 모든 이터러블이 올 수 있다. 

``` jsx
//배열뿐만 아니라 모든 이터러블(iterable, 반복 가능한 객체)에 구조 분해 할당을 적용할 수 있습니다
let [a, b, c] = "abc"; // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3]);
```

* 할당 연산자 좌측엔 뭐든지 올 수 있다(객체도 가능)

``` jsx
let user = {};
[user.name, user.surname] = "Bora Lee".split(" ");

console.log(user.name); // Bora
```

* entries()로 반복하기 

``` jsx
let user = {
  name: "John",
  age: 30
};

// 객체의 키와 값 순회하기
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, age:30이 차례대로 출력
}
```


* 변수 교환 트릭
``` jsx
let guest = "Jane";
let admin = "Pete";

// 변수 guest엔 Pete, 변수 admin엔 Jane이 저장되도록 값을 교환함
[guest, admin] = [admin, guest];

console.log(`${guest} ${admin}`);
```

## '...'로 나머지 요소 가져오기 
배열 앞쪽에 위치한 값 몇 개만 필요하고 그 이후 이어지는 나머지 값들은 한데 모아서 저장하고 싶을 때가 있습니다. 이럴 때는 점 세 개 ...를 붙인 매개변수 하나를 추가하면 ‘나머지(rest)’ 요소를 가져올 수 있습니다.

``` jsx
let [name1, name2, ...rest] = [
  "Julius",
  "Caesar",
  "Consul",
  "of the Roman Republic",
];

console.log(name1); //Julius
console.log(name2); //Caesar
console.log(rest); //[ 'Consul', 'of the Roman Republic' ]

console.log(rest[0]); //Consul
```
rest는 나머지 배열 요소들이 저장된 새로운 배열이 된다. 
rest대신에 다른 이름을 사용해도 되는데, 변수 앞의 점 세개와 변수가 가장 마지막에 위치해야 한다는 점은 지켜야한다. 

``` jsx
let [name1, ...rest, name2 ] = [
  "Julius",
  "Caesar",
  "Consul",
  "of the Roman Republic",
];
``` 
이렇게 하면 안된다. 

## 기본값
할당하고자 하는 변수의 개수가 분해하고자 하는 배열의 길이보다 크더라도 에러가 발생하지 않습니다. 할당할 값이 없으면 undefined로 취급되기 때문이다. 

``` jsx
let [firstName, surname] = [];

console.log(firstName); // undefined
console.log(surname); // undefined
```

=을 이용하면 할당할 값이 없을 때 기본 할당값 설정 가능
``` jsx
// 기본값
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

console.log(name); // Julius (배열에서 받아온 값)
console.log(surname); // Anonymous (기본값)
```

복잡한 표현식이나 함수 호출도 기본값이 될 수 있습니다. 이렇게 기본식으로 표현식이나 함수를 설정하면 할당할 값이 없을 때 표현식이 평가되거나 함수가 호출됩니다.
``` jsx
// name의 prompt만 실행됨
let [surname = prompt('성을 입력하세요.'), name = prompt('이름을 입력하세요.')] = ["김"];

alert(surname); // 김 (배열에서 받아온 값)
alert(name);    // prompt에서 받아온 값
```

## 객체 분해하기 
``` jsx
let {var1, var2} = {va1:..., var2:...}
```
할당 연산자 우측엔 분해하고자 하는 객체를, 좌측엔 상응하는 객체 프로퍼티의 패턴을 넣는다.

키와 다른 이름으로 변수 저장하기 

```jsx
let options = {
  title: "Menu",
  width: 100,
  height: 200,
};
let { width: w, height: h, title } = options;

console.log(title); //Menu
console.log(w); // 100
console.log(h); // 200
```

프로퍼티가 없는 경우
``` jsx
let options = {
  title: "Menu",
};
let { width = 100, height = 200, title } = options;

console.log(title); //Menu
console.log(width); // 100
console.log(height); // 200
```

콜론과 할당 연산자 동시 사용하기 
``` jsx
let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
```

프로퍼티가 많은 복잡한 객체에서 원하는 정보만 뽑아오기 
``` jsx
let options = {
  title: "Menu",
  width: 100,
  height: 200,
};

// title만 변수로 뽑아내기
let { title } = options;

console.log(title);
console.log(typeof title); //string
```

## 나머지 패턴
분해하려는 객체의 프로퍼티가 할당하려는 변수의 개수보다 많으면 어떡하지?
=> 나머지 패턴 사용하기 
주의: 모던 브라우저는 나머지 패턴을 지원하지만, IE를 비롯한 몇몇 구식 브라우저는 나머지 패턴을 지원하지 않음(=> 해결법: 바벨 사용)

``` jsx
let options = {
  title: "Menu",
  width: 100,
  height: 200,
};

// title = 이름이 title인 프로퍼티
// rest = 나머지 프로퍼티들
let { title, ...rest } = options;

// title엔 "Menu", rest엔 {height: 200, width: 100}이 할당됩니다.
console.log(rest.height); // 200
console.log(rest.width); // 100
console.log(typeof rest); //object
```

let 없이 사용하기 

잘못된 코드 
``` jsx
let title, width, height;

// SyntaxError: Unexpected token '=' 이라는 에러가 아랫줄에서 발생합니다.
{title, width, height} = {title: "Menu", width: 200, height: 100};
```

에러를 해결하려면 할당문을 괄호(...)로 감싸 자바스크립트가 {...}를 코드 블록이 아닌 표현식으로 해석하면된다. 
``` jsx
let title, width, height;

// 에러가 발생하지 않습니다.
({title, width, height} = {title: "Menu", width: 200, height: 100});

alert( title ); // Menu
```

## 중첩구조 분해 
``` jsx
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// 코드를 여러 줄에 걸쳐 작성해 의도하는 바를 명확히 드러냄
let {
  size: { // size는 여기,
    width,
    height
  },
  items: [item1, item2], // items는 여기에 할당함
  title = "Menu" // 분해하려는 객체에 title 프로퍼티가 없으므로 기본값을 사용함
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
```


## 똑똑한 함수 매개 변수

함수에 매개변수가 많은데 이중 상당수는 선택적으로 쓰이는 경우가 종종있다. 
사용자 인터페이스와 연관된 함수에서 이런 상황을 자주 볼 수 있다. 
메뉴 생성에 관여하는 함수가 있다고 할때, 메뉴엔 너비, 
